{"config":{"lang":["en","ja"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p> \ud83e\uddda\ud83c\udffb\u200d\ufe0f YiVal </p> <p>      Website      \u00b7        Producthunt    \u00b7        Documentation    </p> <p> \u26a1 Build any Generative AI application with evaluation         and improvement \u26a1 </p> <p>\ud83d\udc49 Follow us:  | </p> <p> </p>"},{"location":"#what-is-yival","title":"\ud83e\udd14 What is YiVal?","text":"<p>YiVal is an GenAI-Ops framework that allows you to iteratively tune your Generative  AI model metadata, params, prompts and retrieval configs all at once with your  preferred choices of test dataset generation, evaluation algorithms and improvement strategies.   </p> <p>Check out our quickstart guide! \u2192</p>"},{"location":"#whats-next","title":"\ud83d\udce3 What's Next?","text":""},{"location":"#expected-features-in-sep","title":"Expected Features in Sep","text":"<ul> <li>Add ROUGE and BERTScore evaluators</li> <li>Add support to midjourney</li> <li>Add support to LLaMA2-70B, LLaMA2-7B, Falcon-40B,</li> <li>Support LoRA fine-tune to open source models</li> </ul>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"\ud83d\udd27 Experiment Mode: \ud83e\udd16 Agent Mode (Auto-prompting): Workflow Define your AI/ML application \u27a1\ufe0f Define test dataset \u27a1\ufe0f Evaluate \ud83d\udd04 Improve \u27a1\ufe0f Prompt related artifacts built \u2705 Define your AI/ML application \u27a1\ufe0f Auto-prompting \u27a1\ufe0f Prompt related artifacts built \u2705 Features \ud83c\udf1f Streamlined prompt development process \ud83c\udf1f Support for multimedia and multimodel \ud83c\udf1f Support CSV upload and GPT4 generated test data\ud83c\udf1f Dashboard tracking latency, price and evaluator results \ud83c\udf1f Human(RLHF) and algorithm based improvers \ud83c\udf1f Service with detailed web view\ud83c\udf1f Customizable evaluators and improvers \ud83c\udf1f Non-code experience of Gen-AI application build  \ud83c\udf1f Witness your Gen-AI application born and improve with just one click Demos - Startup Company Headline Generation Bot\ud83d\udd25"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install yival\n</code></pre>"},{"location":"#demo","title":"Demo","text":""},{"location":"#basic-interactive-mode","title":"Basic Interactive Mode","text":"<p>To get started with a demo for basic interactive mode of YiVal, run the following command:</p> <pre><code>yival demo --basic_interactive\n</code></pre> <p>Once started, navigate to the following address in your web browser:</p> <p>http://127.0.0.1:8073/interactive</p> Click to view the screenshot    ![Screenshot 2023-08-17 at 10 55 31 PM](https://github.com/YiVal/YiVal/assets/1544154/a720c3ad-1288-4830-8a3d-377d9827f46e)   <p>For more details on this demo, check out the Basic Interactive Mode Demo.</p>"},{"location":"#question-answering-with-expected-result-evaluator","title":"Question Answering with expected result evaluator","text":"<pre><code>yival demo --qa_expected_results\n</code></pre> <p>Once started, navigate to the following address in your web browser: http://127.0.0.1:8073/</p> Click to view the screenshot <p>For more details, check out the Question Answering with expected result evaluator.</p>"},{"location":"#fun-cast-fortune-telling","title":"Fun Cast Fortune Telling","text":"<p>Dive into the world of YiChing and discover your fortune on our index page. A fun and interactive way to get started with Yival.</p> <p></p>"},{"location":"architecture/","title":"Architecture","text":"<pre><code>flowchart TD\n\n    %% Data Generation Stage\n    A[Start]\n    A --&gt; |Data Generation| A1[Dataset]\n    A1 --&gt; A2[DataGenerator]\n    A2 --&gt; A3[Specific Generator]\n    A1 --&gt; A4[DataReader]\n    A4 --&gt; A5[Specific Reader]\n    A1 --&gt; A6[Manual Input]\n\n    %% Create Combinations Stage\n    A1 --&gt; |Create Combinations| B\n    B --&gt; B1[Specific Combination Creator]\n    B --&gt; B2[Set Combinations Manually]\n    B --&gt; B3[List of Combinations]\n\n    %% Evaluate Stage\n    B3 --&gt; |Analysis| C\n    C --&gt; C1[User's Function]\n    C --&gt; C2[Results from Function]\n    A1 --&gt; C1\n\n    %% Evaluator Stage\n    C2 --&gt; |Evaluation| D\n    D --&gt; D1[Method 1]\n    D --&gt; D2[Method 2]\n    D --&gt; D3[Method 3]\n\n    %% Select Stage\n    D --&gt; |Selection| E\n\n    %% Improver Stage\n    E --&gt; |Improvement| F\n    F --&gt; F1[Improver]\n    F1 --&gt; C\n\n    %% Styling\n    style A fill:#f9d77e,stroke:#f96e5b\n    style B fill:#a1d4c6,stroke:#f96e5b\n    style C fill:#f6c3d5,stroke:#f96e5b\n    style D fill:#b2b1cf,stroke:#f96e5b\n    style E fill:#f9efaa,stroke:#f96e5b\n    style F fill:#f2a3b3,stroke:#f96e5b</code></pre>"},{"location":"architecture/#data-generation","title":"Data Generation","text":"<p>The process starts with the generation of a dataset which can come from multiple sources:</p> <ul> <li>Specific Data Generator: A defined method or algorithm that automatically                                churns out data.</li> <li>Data Reader: A component that reads data from external places.</li> <li>Manual Input: As straightforward as it sounds, data can be added manually.</li> </ul>"},{"location":"architecture/#combination-creation","title":"Combination Creation","text":"<p>Once we have our dataset, we form combinations that are pivotal for the subsequent analysis:</p> <ul> <li>Formed using specific combination creators.</li> <li>Defined manually.</li> </ul>"},{"location":"architecture/#analysis","title":"Analysis","text":"<p>This is the heart of the Yival framework. A custom function provided by the user takes in the dataset and combination list to produce valuable insights.</p>"},{"location":"architecture/#evaluation","title":"Evaluation","text":"<p>After analysis, the results are subjected to evaluation. Several methodologies can be applied to grasp and gauge the data's behavior deeply.</p>"},{"location":"architecture/#selection","title":"Selection","text":"<p>From the evaluations, the most promising results are selected. This process ensures only the most vital insights are pushed forward.</p>"},{"location":"architecture/#improvement","title":"Improvement","text":"<p>The selected results are then fine-tuned in this phase. An \"Improver\" is applied to enhance these results. This stage can loop back to the analysis stage, indicating an ongoing, iterative process of refinement.</p>"},{"location":"auto_prompts_generation/","title":"Auto Prompts Generation","text":""},{"location":"auto_prompts_generation/#overview","title":"Overview","text":"<p>This document describes the engineering specification auto prompt generation demo</p>"},{"location":"auto_prompts_generation/#flow-diagram","title":"Flow Diagram","text":"<pre><code>flowchart TD\n\n    %% Data Generation Stage\n    A[Start]\n    A --&gt; |Data Generation| A1[Dataset]\n    A1 --&gt; A2[DataGenerator]\n    A2 --&gt; A3[OpenAI Prompt Data Generator]\n\n    %% Create Combinations Stage\n    A1 --&gt; |Create Combinations| B\n    B --&gt; B1[OpenAI Prompt Based Variation Generator]\n    B --&gt; B2[Set Combinations Manually]\n    B --&gt; B3[List of Combinations]\n\n    %% Evaluate Stage\n    B3 --&gt; |Analysis| C\n    C --&gt; C1[User's Function - Headline Generation]\n    C --&gt; C2[Results from Function]\n    A1 --&gt; C1\n\n    %% Evaluator Stage\n    C2 --&gt; |Evaluation| D\n    D --&gt; D1[OpenAI Prompt Based Evaluator: clarity]\n    D --&gt; D2[OpenAI Prompt Based Evaluator: catchiness]\n    D --&gt; D3[OpenAI Prompt Based Evaluator: relevance]\n    D --&gt; D4[OpenAI Elo Evaluator]\n\n    %% Select Stage\n    D --&gt; |Selection| E\n    E --&gt; E1[Selection Strategy]\n    E1 --&gt; E2[AHP Selection Strategy]\n\n    %% Improver Stage\n    E --&gt; |Improvement| F\n    F --&gt; F1[OpenAI PromptBased Combination Improver]\n    F1 --&gt; C\n\n    %% Styling\n    style A fill:#f9d77e,stroke:#f96e5b\n    style B fill:#a1d4c6,stroke:#f96e5b\n    style C fill:#f6c3d5,stroke:#f96e5b\n    style D fill:#b2b1cf,stroke:#f96e5b\n    style E fill:#f9efaa,stroke:#f96e5b\n    style F fill:#f2a3b3,stroke:#f96e5b</code></pre>"},{"location":"auto_prompts_generation/#specifications","title":"Specifications","text":""},{"location":"auto_prompts_generation/#data-generator","title":"Data Generator","text":"<p>We use open ai to help us generate test cases</p> <pre><code>dataset:\ndata_generators:\nopenai_prompt_data_generator:\nchunk_size: 1000\ndiversify: false\ninput_function:\ndescription:\nGiven an tech startup business, generate a corresponding landing\npage headline\nname: headline_generation_for_tech_startup_business\nparameters:\ntech_startup_business: str\nnumber_of_examples: 2\nopenai_model_name: gpt-4\noutput_path: test_demo_generated_examples.pkl\nprompt: |-\nPlease provide a concrete and realistic test case as\na dictionary for function invocation using the ** operator.\nOnly include parameters, excluding description and name and ensure\nit's succinct and well-structured.\n\n**Only provide the dictionary.**\n\nsource_type: machine_generated\n</code></pre> <ul> <li>diversify: Whether to diversify the generated results. If set to true,                  parallel processing of data generation is not possible.</li> <li>input_function: Description and parameters for the function.</li> <li>number_of_examples: Number of examples to be generated.</li> <li>output_path: Temporary output path for the generated data. If this file exists,                    the data will be read from it.</li> <li>prompt: The prompt used to generate the data.</li> </ul>"},{"location":"auto_prompts_generation/#custom-function","title":"Custom Function","text":"<p>The custom function for this mode is hosted on GitHub. You can find and review it here.</p> <p>In this function, we take in an input that represents tech startup business, and will otuput headline for the landing page.</p> <p>We make use of the <code>StringWrapper</code> to enclose placeholders intended for replacement, based on the variations configuration. This wrapped string essentially serves as a namespace:</p> <pre><code>    str(\n        StringWrapper(\n            template=\"\"\"\n            Generate a landing page headline for {tech_startup_business}\n            \"\"\",\n            variables={\n                \"tech_startup_business\": tech_startup_business,\n            },\n            name=\"task\"\n            )\n        )\n</code></pre> <p>Within the <code>StringWrapper</code>, instead of a raw string, we utilize a template. This template integrates both text and variables. The variables are encapsulated within <code>{}</code> braces. In the example provided, the variable is <code>tech_startup_business</code>.</p>"},{"location":"auto_prompts_generation/#variations-generation","title":"Variations Generation","text":"<p>We have configured variations using both ChatGPT and manual settings. Here's the configuration for ChatGPT:</p> <pre><code>variations:\n- name: task\ngenerator_name: openai_prompt_based_variation_generator\ngenerator_config:\ndiversify: false\nmax_tokens: 7000\nnumber_of_variations: 2\nopenai_model_name: gpt-4\noutput_path: test_demo_generated_prompt.pkl\nprompt:\n- content: |- Prompt used to generate the varations. \n</code></pre> <ul> <li>generator_name: Represents the class name of the generator.</li> <li>number_of_variations: Specifies the number of variations to be generated.</li> <li>output_path: This is the temporary storage location for the generated data.                    If a file at this path exists, the data is read from it.</li> <li>prompt: The prompts used to generate the variation.</li> </ul> <p>For manual variations, the configuration is as follows:</p> <pre><code>    variations:\n- instantiated_value: Generate landing page headline for {tech_startup_business}\nvalue: Generate landing page headline for {tech_startup_business}\nvalue_type: str\nvariation_id: null\n</code></pre> <p>This manual setup defines a specific way the variation will be presented.</p>"},{"location":"auto_prompts_generation/#human-rating-configuration","title":"Human Rating Configuration","text":"<p>Below is the configuration for human ratings:</p> <pre><code>human_rating_configs:\n\n- name: clarity\ninstructions: Evaluate the clarity of the headline: Does it precisely convey the startup's purpose?\nscale: [1, 5]\n\n- name: relevance\ninstructions: Assess the relevance of the headline: Is it pertinent to the subject matter?\nscale: [1, 5]\n</code></pre> <p>Explanation:</p> <ul> <li>name: Specifies the criterion for rating.</li> <li>instructions: Provides guidelines to the rater on how to evaluate the content                     based on the defined criterion.</li> <li>scale: The rating scale, where <code>1</code> is the lowest and <code>5</code> is the highest.</li> </ul> <p>To better understand the configuration, refer to the screenshot below:</p> <p></p> <p>Certainly! Here's the revised description taking into account the context you provided:</p>"},{"location":"auto_prompts_generation/#automated-evaluation-configuration","title":"Automated Evaluation Configuration","text":"<p>Below is the setup for automated evaluations:</p> <pre><code>evaluators:\n- evaluator_type: all\ninput_description:\nGiven a tech startup business, produce a single corresponding landing\npage headline\nname: openai_elo_evaluator\nopenai_model_name: gpt-4\n- evaluator_type: individual\nmetric_calculators:\n- method: AVERAGE\nname: openai_prompt_based_evaluator\nprompt: |-\nYou're tasked with evaluating an answer for a specific criterion based on the following information:\n- Task: Given a tech startup business, produce a single corresponding landing page headline\n- Question: Does the headline clearly convey the startup's mission or the problem it addresses?\nThe headline should instantly provide clarity about the startup's objective to any reader. Ambiguities can deter potential users or investors.\n[Input]: {tech_startup_business}\n[Result]: {raw_output}\nKindly rate the response based on the following options:\nA. Doesn't meet the criterion.\nB. Partially meets the criterion with significant scope for enhancement.\nC. Adequately meets the criterion.\nD. Meets the criterion impressively.\nE. Exemplarily meets the criterion, with negligible areas for improvement.\ndisplay_name: clarity\nchoices: [\"A\", \"B\", \"C\", \"D\", \"E\"]\ndescription: Does the headline lucidly articulate the startup's function or the issue it targets?\nscale_description: \"0-4\"\nchoice_scores:\nA: 0\nB: 1\nC: 2\nD: 3\nE: 4\n</code></pre> <p>Explanation:</p> <ul> <li>evaluator_type: Designates the type of evaluation.<ul> <li><code>all</code>: The evaluator considers all experiment results across all variations.     It uses the elo algorithm and employs GPT-4 as the judge.</li> <li><code>individual</code>: The evaluator focuses solely on the current variation's results.</li> </ul> </li> <li>input_description: Describes the type of input the model expects.</li> <li>name: Represents the evaluator's name or identifier.</li> <li>prompt: Provides the template and context for the automated evaluator     to assess a given result.</li> <li>display_name: Specifies the displayed criterion name on the user interface.</li> <li>choices: Lists all possible rating options for the evaluator.</li> <li>description: Offers a brief description of the evaluation criterion.</li> <li>scale_description: Details the numeric scoring scale.</li> <li>choice_scores: Maps each choice to its respective numeric score.</li> </ul> <p>Certainly! Here's the polished description for the selection configuration:</p>"},{"location":"auto_prompts_generation/#selection-configuration","title":"Selection Configuration","text":"<p>Below is the setup detailing the selection strategy:</p> <pre><code>selection_strategy:\nahp_selection:\ncriteria:\n- openai_elo_evaluator\n- average_token_usage\n- average_latency\n- \"openai_prompt_based_evaluator: clarity\"\n- \"openai_prompt_based_evaluator: relevance\"\n- \"openai_prompt_based_evaluator: catchiness\"\ncriteria_maximization:\nopenai_elo_evaluator: true\naverage_latency: false\naverage_token_usage: false\ncriteria_weights:\nopenai_elo_evaluator: 0.3\naverage_latency: 0.2\naverage_token_usage: 0.2\n\"openai_prompt_based_evaluator: clarity\": 0.1\n\"openai_prompt_based_evaluator: relevance\": 0.1\n\"openai_prompt_based_evaluator: catchiness\": 0.1\n</code></pre> <p>Explanation:</p> <ul> <li>selection_strategy: Represents the overarching approach for making selections.</li> <li>ahp_selection: Specifies that the Analytic Hierarchy Process (AHP) algorithm     is employed for the selection strategy.</li> <li>criteria: Lists the evaluators and metrics that are considered during     the selection process.</li> <li>criteria_maximization: Indicates whether each criterion should be maximized.     For instance,     while a high score from the <code>openai_elo_evaluator</code> is desirable (<code>true</code>),     a lower <code>average_latency</code> or <code>average_token_usage</code> is preferred (<code>false</code>).</li> <li>criteria_weights:     Assigns a weight to each criterion,     determining its importance in the overall evaluation.     The weights sum up to 1, indicating the relative significance of each criterion     in the final decision-making process.</li> </ul>"},{"location":"auto_prompts_generation/#auto-improver","title":"Auto Improver","text":"<p>Certainly! Here's the enhanced description, incorporating the additional information:</p>"},{"location":"auto_prompts_generation/#auto-improver-configuration","title":"Auto Improver Configuration","text":"<p>Below is the setup detailing the auto improver strategy:</p> <pre><code>improver:\nname: openai_prompt_based_combination_improver\nmax_iterations: 2\nopenai_model_name: gpt-4\nstop_conditions:\n\"openai_prompt_based_evaluator: catchiness\": 3\n\"openai_prompt_based_evaluator: clarity\": 3\n\"openai_prompt_based_evaluator: relevance\": 3\n</code></pre> <p>Explanation:</p> <ul> <li>name: Specifies the identifier or the class of the improver.     In this instance, <code>openai_prompt_based_combination_improver</code> is utilized.</li> <li>max_iterations: Designates the upper limit for the number of improvement cycles.     The process will not exceed 2 iterations, irrespective of other conditions.</li> <li>openai_model_name:     Indicates the model to be utilized for the improvement process,     which here is <code>gpt-4</code>.</li> <li>stop_conditions:     Outlines conditions under which the improver should halt its operations     before reaching the maximum iteration count.     The improvement process will terminate if the average score     from any of the specified evaluators surpasses 3.</li> </ul> <p>Additionally, it's important to note that during the improvement process, only the best result from the previous selection step will be taken into consideration. The idea is to refine and optimize this top-performing result further.</p>"},{"location":"auto_prompts_generation/#full-configuration","title":"Full Configuration","text":"<p>For a comprehensive view of all configurations related to the basic interactive mode, you can review the full configuration file hosted here.</p>"},{"location":"basic_interactive_mode/","title":"Basic Interactive Mode","text":""},{"location":"basic_interactive_mode/#overview","title":"Overview","text":"<p>This document describes the engineering specification for the basic interactive mode in the YiVal framework.</p>"},{"location":"basic_interactive_mode/#flow-diagram","title":"Flow Diagram","text":"<pre><code>flowchart TD\n\n    %% Data Generation Stage (simplified)\n    A[Start]\n    A --&gt; |Data Generation| A1[Manual Input]\n\n    %% Create Combinations Stage (simplified)\n    A1 --&gt; |Create Combinations| B\n    B --&gt; B1[Set Combinations Manually]\n\n    %% Evaluate Stage (simplified)\n    B1 --&gt; |Analysis| C\n    C --&gt; C1[User's Function]\n    A1 --&gt; C1\n    C --&gt; C2[Results from Function]\n\n    %% Styling\n    style A fill:#f9d77e,stroke:#f96e5b\n    style B fill:#a1d4c6,stroke:#f96e5b\n    style C fill:#f6c3d5,stroke:#f96e5b\n</code></pre>"},{"location":"basic_interactive_mode/#specifications","title":"Specifications","text":""},{"location":"basic_interactive_mode/#data-source","title":"Data Source","text":"<p>The data for this mode comes directly from the user input. The configuration for this data source is as follows:</p> <pre><code>dataset:\nsource_type: user_input\n</code></pre>"},{"location":"basic_interactive_mode/#custom-function","title":"Custom Function","text":"<p>The custom function for this mode is hosted on GitHub. You can find and review it here.</p> <p>Within this function, we utilize the <code>StringWrapper</code> to wrap places that will be replaced based on the variations configuration. The wrapped string acts as a namespace:</p> <pre><code>str(\n    StringWrapper(\n        \"Translate the following to Chinese\", name=\"translate\"\n    )\n) + f'{input}'\n</code></pre>"},{"location":"basic_interactive_mode/#variations-configuration","title":"Variations Configuration","text":"<p>The variations are defined in a configuration that provides multiple instantiated values, each corresponding to a different language. Here's a snapshot:</p> <pre><code>variations:\n- name: translate\nvariations:\n- instantiated_value: \"Translate the following to Chinese:\"\nvalue: \"Translate the following to Chinese\"\nvalue_type: str\nvariation_id: null\n- instantiated_value: \"Translate the following to Spanish:\"\nvalue: \"Translate the following to Spanish\"\nvalue_type: str\nvariation_id: null\n- instantiated_value: \"Translate the following to German:\"\nvalue: \"Translate the following to German\"\nvalue_type: str\nvariation_id: null\n</code></pre> <p>This configuration provides three variations, allowing the text to be set in different languages.</p>"},{"location":"basic_interactive_mode/#full-configuration","title":"Full Configuration","text":"<p>For a comprehensive view of all configurations related to the basic interactive mode, you can review the full configuration file hosted here.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#change-log","title":"Change Log","text":""},{"location":"changelog/#010","title":"0.1.0","text":"<p>Qian (The Creative, Heaven) \ud83c\udf24\ufe0f (\u4e7e):</p> <ul> <li> Setup the framework for wrappers that can be used directly     in the production code.<ul> <li> Set up the BaseWrapper</li> <li> Set up the StringWrapper</li> </ul> </li> <li> Setup the config framework</li> <li> Setup the experiment main function</li> <li> Setup the evaluator framework to do evaluations<ul> <li> One auto-evaluator</li> <li> Ground truth matching</li> <li> Human evaluator</li> </ul> </li> <li> Interactive evaluator</li> <li> Reader framework that be able to process different data<ul> <li> One reader from csv</li> </ul> </li> <li> Output formatter<ul> <li> Output to csv</li> <li> Basic Textual UI</li> </ul> </li> <li> Output parser - Capture detailed information</li> <li> Documents</li> <li> Git setup</li> <li> Cotribution guid</li> <li> End2End Examples</li> <li> Release</li> </ul>"},{"location":"contributing/","title":"Contributing Guide","text":""},{"location":"contributing/#preparation","title":"Preparation","text":"<p>You need an Python 3.10+ environment with poetry.</p> <p>Example</p> LinuxMac OSWindowsOther <p>For example, in Ubuntu 22.04, you can run:</p> <pre><code>sudo apt install python3-pip\nsudo pip install poetry\n</code></pre> <pre><code>brew install python@3.10\n\nbrew install poetry\n# Or\npython3 -m pip install --user poetry\n</code></pre> <p>Download exe installer from python.org, or use Chocolatey :</p> <pre><code>choco install python\npython3 -m pip install poetry\n</code></pre> <p>There should be a reboot.</p> <p>See poetry document for installation guide.</p>"},{"location":"contributing/#setup","title":"Setup","text":"<p>Initialize a Python virtual environment with <code>poetry</code>:</p> <pre><code>poetry install --sync\n</code></pre>"},{"location":"contributing/#development","title":"Development","text":"<p>A vscode is recommended. There are some configurations in <code>.vscode/</code> of this project.</p> <p>The commands below should be executed inside <code>poetry shell</code>, or with prefix <code>poetry run</code>.</p>"},{"location":"contributing/#test","title":"Test","text":"<pre><code>pytest\n</code></pre>"},{"location":"contributing/#mkdocs","title":"Mkdocs","text":"<p>Preview the docs locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"qa_expected_results/","title":"Question Answering with Expected Results","text":""},{"location":"qa_expected_results/#overview","title":"Overview","text":"<p>This documentation provides an insight into the basic reader and evaluator components within the Yival framework.</p>"},{"location":"qa_expected_results/#flow-diagram","title":"Flow Diagram","text":"<p>To better understand the process, refer to the flow diagram below:</p> <pre><code>flowchart TD\n\n    %% Data Generation Stage\n    A[Start]\n    A --&gt; |Data Generation| A1[Dataset]\n    A1 --&gt; A2[DataReader]\n    A2 --&gt; A3[CSVReader]\n    A1 --&gt; A6[Manual Input]\n\n    %% Create Combinations Stage\n    A1 --&gt; |Create Combinations| B\n    B --&gt; B2[Set Combinations Manually]\n\n    %% Evaluate Stage\n    B2 --&gt; |Analysis| C\n    C --&gt; C1[User's Function]\n    C --&gt; C2[Results from Function]\n\n    %% Evaluator Stage\n    C2 --&gt; |Evaluation| D\n    D --&gt; D3[String_Expected_results_Evaluator]\n\n    %% Styling\n    style A fill:#f9d77e,stroke:#f96e5b\n    style B fill:#a1d4c6,stroke:#f96e5b\n    style C fill:#f6c3d5,stroke:#f96e5b\n    style D fill:#b2b1cf,stroke:#f96e5b</code></pre>"},{"location":"qa_expected_results/#specifications","title":"Specifications","text":""},{"location":"qa_expected_results/#data-source","title":"Data Source","text":"<p>The data for this example is sourced from a CSV file that includes an <code>expected_result</code> column. Here's the configuration for the data source:</p> <pre><code>dataset:\nfile_path: demo/data/yival_expected_results.csv\nreader: csv_reader\nsource_type: dataset\nreader_config:\nexpected_result_column: expected_result\n</code></pre>"},{"location":"qa_expected_results/#custom-function","title":"Custom Function","text":"<p>Our custom function tailored for this mode is hosted on GitHub. To delve into its details, please click here.</p> <p>In this function, the <code>StringWrapper</code> is employed to encapsulate parts of the string that will be substituted based on the variations configuration. This encapsulated string serves as a namespace:</p> <pre><code>    \"content\": f'{input} ' + str(StringWrapper(\"\", name=\"qa\"))\n</code></pre>"},{"location":"qa_expected_results/#variations-configuration","title":"Variations Configuration","text":"<p>Variations are articulated in a dedicated configuration. This particular setup allows retaining the original empty suffix or appends a \"Chain of Thought\" suffix:</p> <pre><code>variations:\n- name: qa\nvariations:\n- instantiated_value: \"\"\nvalue: \"\"\nvalue_type: str\nvariation_id: null\n- instantiated_value: \"Think first, then make a decision. Some random thoughts:\"\nvalue: \"Think first, then make a decision. Some random thoughts:\"\nvalue_type: str\nvariation_id: null\n</code></pre>"},{"location":"qa_expected_results/#full-configuration","title":"Full Configuration","text":"<p>For those seeking an in-depth exploration of all configurations pertinent to the QA expected results demonstration, we recommend perusing the comprehensive configuration file available here.</p>"},{"location":"blog/prompt_generation_using_retrivel/","title":"Simplifying Prompt Generation for LLMs with Retrieval Methods","text":"<p>Working with Large Language Models (LLMs) like ChatGPT often involves feeding them prompts: short texts that give the model direction on how to respond. Manually crafting these prompts can be tedious. Wouldn't it be convenient if we could automate this process, ensuring each prompt is contextually relevant? Let's explore a method that does just that, using the Yival framework and the FAISS vector database.</p>"},{"location":"blog/prompt_generation_using_retrivel/#why-automate-prompt-generation","title":"Why Automate Prompt Generation?","text":"<p>Think of prompts as questions or instructions you give to ChatGPT. The more precise the instruction, the better the model's answer. But crafting a new instruction for every unique scenario is time-consuming. If we could automate this, not only would it save time, but it'd also ensure the AI's responses are consistently relevant.</p>"},{"location":"blog/prompt_generation_using_retrivel/#storing-prompts-faiss-to-the-rescue","title":"Storing Prompts: FAISS to the Rescue","text":"<p>We source a wide variety of prompts from awesome-chatgpt-prompts. To quickly find the best prompt for any situation:</p> <ul> <li>We use FAISS: This tool helps store prompts in a way that makes them quick   to search and retrieve.</li> <li>We turn prompts into 'vectors': By transforming prompts into a mathematical   format (vectors), we can easily find the most fitting one for a given situation.</li> </ul>"},{"location":"blog/prompt_generation_using_retrivel/#how-yival-helps-in-retrieval","title":"How Yival Helps in Retrieval","text":"<p>Yival is like a toolbox that simplifies AI-related experimentation. When integrated with FAISS, it streamlines the process of fetching the right prompt.</p>"},{"location":"blog/prompt_generation_using_retrivel/#the-main-steps","title":"The Main Steps","text":"<ol> <li>Find Matching Prompts: Based on a given situation, Yival searches the FAISS     database to find similar prompts.</li> <li>Refine with GPT: Sometimes, the initially found prompts might not be perfect.     So, we use GPT to rerank them, ensuring we pick the most suitable one.</li> </ol>"},{"location":"blog/prompt_generation_using_retrivel/#putting-it-all-together","title":"Putting It All Together","text":"<p>With our setup, generating a prompt becomes straightforward. For ChatGPT, here's a simple example of how we might use a generated prompt:</p> <pre><code># Create a chat message sequence\nmessages = [{\n    \"role\": \"user\",\n    \"content\": str(StringWrapper(\"\", name=\"prompt\")) + f'\\n{input}'\n}]\n# Get a response from ChatGPT\nresponse = openai.ChatCompletion.create(\n    model=\"gpt-3.5-turbo\", messages=messages\n)\n</code></pre> <p>Notice that we didn't need to provide a predefined prompt. The system took care of it!</p>"},{"location":"blog/prompt_generation_using_retrivel/#a-peek-at-the-process","title":"A Peek at the Process","text":""},{"location":"blog/prompt_generation_using_retrivel/#visual-flow","title":"Visual Flow","text":"<pre><code>sequenceDiagram\n    participant Y as YivalFrameworks Variation Generation\n    participant C as Custom Function\n    participant E as Yival's Evaluator/Improver\n\n    Note over Y: Start with predefined prompts from Awesome GPT prompt Git library\n\n    Y-&gt;&gt;+Y: Retrieve top 3 prompts from FAISS (Vector Database)\n    Y-&gt;&gt;+Y: Evaluate relevance of prompt with GPT-4\n\n    alt None of the prompts are relevant\n        Y-&gt;&gt;+Y: Request GPT-4 to generate a new prompt\n        Y--&gt;&gt;-Y: Obtain and use new prompt from GPT-4\n    else At least one prompt is relevant\n        Y--&gt;&gt;-Y: Select and use the most relevant prompt from GPT-4\n    end\n\n    Y-&gt;&gt;C: Feed generated variation\n    C--&gt;&gt;E: Return output to Yival's Evaluator/Improver\n</code></pre> <p>This flowchart will give you a bird's-eye view of how everything connects, from the moment we receive a use-case to generating the perfect prompt.</p>"},{"location":"blog/prompt_generation_using_retrivel/#results-in-real-time","title":"Results in Real-Time","text":"<p>Here's an example of what the system's output looks like in action. This gives you an idea of the kind of prompts it can generate and how ChatGPT might respond.</p>"},{"location":"blog/prompt_generation_using_retrivel/#in-conclusion","title":"In Conclusion","text":"<p>The world of AI is vast and sometimes complex. But tools like Yival and FAISS, when combined with LLMs like ChatGPT, can make tasks like prompt generation much simpler. By automating this process, we're taking a step towards more efficient and context-aware AI interactions.</p> <p>You can review the full code here</p>"},{"location":"blog/yival_introduction/","title":"Introducing Yival: Prompt Development and Experimentation Simplified","text":"<p>The landscape of Artificial Intelligence Generated Content (AIGC) applications is evolving rapidly. In this dynamic environment, Yival offers a structured yet flexible open-source framework tailored for AIGC app development and experimentation.</p>"},{"location":"blog/yival_introduction/#yivals-architecture-structured-flexibility","title":"Yival's Architecture: Structured Flexibility","text":"<p>Yival is designed with modularity at its core, providing a clear workflow to guide users through the stages of AIGC app development.</p> <pre><code>flowchart TD\n\n    %% Data Generation Stage\n    A[Start]\n    A --&gt; |Data Generation| A1[Dataset]\n    A1 --&gt; A2[DataGenerator]\n    A2 --&gt; A3[Specific Generator]\n    A1 --&gt; A4[DataReader]\n    A4 --&gt; A5[Specific Reader]\n    A1 --&gt; A6[Manual Input]\n\n    %% Create Combinations Stage\n    A1 --&gt; |Create Combinations| B\n    B --&gt; B1[Specific Combination Creator]\n    B --&gt; B2[Set Combinations Manually]\n    B --&gt; B3[List of Combinations]\n\n    %% Evaluate Stage\n    B3 --&gt; |Analysis| C\n    C --&gt; C1[User's Function]\n    C --&gt; C2[Results from Function]\n    A1 --&gt; C1\n\n    %% Evaluator Stage\n    C2 --&gt; |Evaluation| D\n    D --&gt; D1[Method 1]\n    D --&gt; D2[Method 2]\n    D --&gt; D3[Method 3]\n\n    %% Select Stage\n    D --&gt; |Selection| E\n\n    %% Improver Stage\n    E --&gt; |Improvement| F\n    F --&gt; F1[Improver]\n    F1 --&gt; C\n\n    %% Styling\n    style A fill:#f9d77e,stroke:#f96e5b\n    style B fill:#a1d4c6,stroke:#f96e5b\n    style C fill:#f6c3d5,stroke:#f96e5b\n    style D fill:#b2b1cf,stroke:#f96e5b\n    style E fill:#f9efaa,stroke:#f96e5b\n    style F fill:#f2a3b3,stroke:#f96e5b</code></pre> <p>A closer look at Yival's structured components:</p> <p>1. Data Generation: The foundation of any AIGC application:</p> <ul> <li>Specific Data Generator: A tool designed to produce data based on predefined                                parameters, often using models for generation.</li> <li>Data Reader: Integrates data from various external sources.</li> <li>Manual Input: For specific needs, direct data input is available.</li> </ul> <p>2. Combination Creation: The next step involves crafting combinations,                              pivotal in AIGC apps:</p> <ul> <li>Defined through specific tools or custom settings.</li> <li>Essentially, it's about defining and experimenting with parameters,   such as the prompt.</li> </ul> <p>3. Evaluation: After processing through a custom function, the output is                    ready for assessment:</p> <ul> <li>Model Evaluator: Uses algorithms to determine the output's quality and relevance.</li> <li>Human Rating: Adds an element of human judgment for a more comprehensive evaluation.</li> </ul> <p>4. Selection: Filters and emphasizes the most relevant outputs, ensuring focused  results.</p> <p>5. Improvement: The framework offers tools to refine results:</p> <ul> <li>Model-driven Improvement: Uses models like LLM for enhancement.</li> <li>Human-guided Refinement: Offers manual refinement options for specific needs.</li> </ul> <p>One of Yival's distinguishing features is its adaptability. Its components are designed to be interchangeable, allowing users to seamlessly integrate custom classes or expand functionalities.</p> <p>Check out our how to build your custom classes here</p>"},{"location":"blog/yival_introduction/#getting-started-with-yival","title":"Getting Started with Yival","text":"<p>For the Beginners: Launch with our pre-built demos. Simply:</p> <ol> <li>Basic Interactive Mode:</li> </ol> <pre><code>pip install yival\nyival demo --basic_interactive\n</code></pre> <p>Dive deeper here.</p> <ol> <li>QA Expected Results:</li> </ol> <pre><code>yival demo --qa_expected_results\n</code></pre> <p>Learn more here.</p> <ol> <li>Auto Prompts Generation:</li> </ol> <pre><code>yival demo --auto_prompts\n</code></pre> <p>Additional details available here.</p> <p>For the Intermediates: Experiment with the Yival framework on our Colab notebook.</p> <p>For the Experts: Delve into our open-source codebase on GitHub.</p>"},{"location":"blog/yival_introduction/#open-source-and-collaborative","title":"Open Source and Collaborative","text":"<p>Yival is more than just a framework; it's an opportunity for collaboration. We welcome contributions, insights, and feedback from the community.</p> <p>Explore Yival and redefine your AIGC development experience.</p>"},{"location":"code/combination_improvers/base_combination_improver/","title":"yival.combination_improvers.base_combination_improver","text":"<p>This module defines the base class for combination improvers.</p> <p>Combination improvers are responsible for improving the combination of experiments based on their experiment results.</p>"},{"location":"code/combination_improvers/base_combination_improver/#yival.combination_improvers.base_combination_improver.BaseCombinationImprover","title":"<code>BaseCombinationImprover</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for all combination improvers.</p> <p>Attributes:</p> Name Type Description <code>_registry</code> <code>Dict[str, Dict[str, Any]]</code> <p>A registry to keep track of</p> <code>default_config</code> <code>Optional[BaseCombinationImproverConfig]</code> <p>Default</p> Source code in <code>src/yival/combination_improvers/base_combination_improver.py</code> <pre><code>class BaseCombinationImprover(ABC):\n\"\"\"\n    Abstract base class for all combination improvers.\n    Attributes:\n        _registry (Dict[str, Dict[str, Any]]): A registry to keep track of\n        combination improvers.\n        default_config (Optional[BaseCombinationImproverConfig]): Default\n        configuration for the combination improver.\n    \"\"\"\n\n    _registry: Dict[str, Dict[str, Any]] = {}\n    default_config: Optional[BaseCombinationImproverConfig] = None\n\n    @classmethod\n    def get_combination_improver(\n        cls, name: str\n    ) -&gt; Optional[Type['BaseCombinationImprover']]:\n\"\"\"Retrieve combination improver class from registry by its name.\"\"\"\n        return cls._registry.get(name, {}).get(\"class\")\n\n    @classmethod\n    def get_default_config(\n        cls, name: str\n    ) -&gt; Optional[BaseCombinationImproverConfig]:\n\"\"\"Retrieve the default configuration of a combination improver by its\n           name.\"\"\"\n        return cls._registry.get(name, {}).get(\"default_config\")\n\n    def __init__(self, config: BaseCombinationImproverConfig):\n        self.config = config\n\n    @classmethod\n    def get_config_class(\n        cls, name: str\n    ) -&gt; Optional[Type[BaseCombinationImproverConfig]]:\n\"\"\"Retrieve the configuration class of a combination imporver by its\n           name.\"\"\"\n        return cls._registry.get(name, {}).get(\"config_cls\")\n\n    @classmethod\n    def register_combination_improver(\n        cls,\n        name: str,\n        combination_improver_cls: Type['BaseCombinationImprover'],\n        config_cls: Optional[Type[BaseCombinationImproverConfig]] = None\n    ):\n\"\"\"Register a new combination improver along with its default\n           configuration and configuration class.\"\"\"\n        cls._registry[name] = {\n            \"class\": combination_improver_cls,\n            \"default_config\": combination_improver_cls.default_config,\n            \"config_cls\": config_cls\n        }\n\n    @abstractmethod\n    def improve(\n        self, experiment: Experiment, config: ExperimentConfig,\n        evaluator: Evaluator, token_logger: TokenLogger\n    ) -&gt; ImproverOutput:\n\"\"\"\n        Improve the experiment based on its results.\n\n        Args:\n            experiment (Experiment): The experiment with its results.\n            config (ExperimentConfig): The original experiment configuration.\n            evaluator (Evaluator): A utility class to evaluate the\n            ExperimentResult. token_logger (TokenLogger): Logs the token usage.\n\n        Returns:\n            ImproverOutput\n        \"\"\"\n</code></pre>"},{"location":"code/combination_improvers/base_combination_improver/#yival.combination_improvers.base_combination_improver.BaseCombinationImprover.get_combination_improver","title":"<code>get_combination_improver(name)</code>  <code>classmethod</code>","text":"<p>Retrieve combination improver class from registry by its name.</p> Source code in <code>src/yival/combination_improvers/base_combination_improver.py</code> <pre><code>@classmethod\ndef get_combination_improver(\n    cls, name: str\n) -&gt; Optional[Type['BaseCombinationImprover']]:\n\"\"\"Retrieve combination improver class from registry by its name.\"\"\"\n    return cls._registry.get(name, {}).get(\"class\")\n</code></pre>"},{"location":"code/combination_improvers/base_combination_improver/#yival.combination_improvers.base_combination_improver.BaseCombinationImprover.get_config_class","title":"<code>get_config_class(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the configuration class of a combination imporver by its name.</p> Source code in <code>src/yival/combination_improvers/base_combination_improver.py</code> <pre><code>@classmethod\ndef get_config_class(\n    cls, name: str\n) -&gt; Optional[Type[BaseCombinationImproverConfig]]:\n\"\"\"Retrieve the configuration class of a combination imporver by its\n       name.\"\"\"\n    return cls._registry.get(name, {}).get(\"config_cls\")\n</code></pre>"},{"location":"code/combination_improvers/base_combination_improver/#yival.combination_improvers.base_combination_improver.BaseCombinationImprover.get_default_config","title":"<code>get_default_config(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the default configuration of a combination improver by its name.</p> Source code in <code>src/yival/combination_improvers/base_combination_improver.py</code> <pre><code>@classmethod\ndef get_default_config(\n    cls, name: str\n) -&gt; Optional[BaseCombinationImproverConfig]:\n\"\"\"Retrieve the default configuration of a combination improver by its\n       name.\"\"\"\n    return cls._registry.get(name, {}).get(\"default_config\")\n</code></pre>"},{"location":"code/combination_improvers/base_combination_improver/#yival.combination_improvers.base_combination_improver.BaseCombinationImprover.improve","title":"<code>improve(experiment, config, evaluator, token_logger)</code>  <code>abstractmethod</code>","text":"<p>Improve the experiment based on its results.</p> <p>Parameters:</p> Name Type Description Default <code>experiment</code> <code>Experiment</code> <p>The experiment with its results.</p> required <code>config</code> <code>ExperimentConfig</code> <p>The original experiment configuration.</p> required <code>evaluator</code> <code>Evaluator</code> <p>A utility class to evaluate the</p> required <code>ExperimentResult.</code> <code>token_logger (TokenLogger</code> <p>Logs the token usage.</p> required <p>Returns:</p> Type Description <code>ImproverOutput</code> <p>ImproverOutput</p> Source code in <code>src/yival/combination_improvers/base_combination_improver.py</code> <pre><code>@abstractmethod\ndef improve(\n    self, experiment: Experiment, config: ExperimentConfig,\n    evaluator: Evaluator, token_logger: TokenLogger\n) -&gt; ImproverOutput:\n\"\"\"\n    Improve the experiment based on its results.\n\n    Args:\n        experiment (Experiment): The experiment with its results.\n        config (ExperimentConfig): The original experiment configuration.\n        evaluator (Evaluator): A utility class to evaluate the\n        ExperimentResult. token_logger (TokenLogger): Logs the token usage.\n\n    Returns:\n        ImproverOutput\n    \"\"\"\n</code></pre>"},{"location":"code/combination_improvers/base_combination_improver/#yival.combination_improvers.base_combination_improver.BaseCombinationImprover.register_combination_improver","title":"<code>register_combination_improver(name, combination_improver_cls, config_cls=None)</code>  <code>classmethod</code>","text":"<p>Register a new combination improver along with its default configuration and configuration class.</p> Source code in <code>src/yival/combination_improvers/base_combination_improver.py</code> <pre><code>@classmethod\ndef register_combination_improver(\n    cls,\n    name: str,\n    combination_improver_cls: Type['BaseCombinationImprover'],\n    config_cls: Optional[Type[BaseCombinationImproverConfig]] = None\n):\n\"\"\"Register a new combination improver along with its default\n       configuration and configuration class.\"\"\"\n    cls._registry[name] = {\n        \"class\": combination_improver_cls,\n        \"default_config\": combination_improver_cls.default_config,\n        \"config_cls\": config_cls\n    }\n</code></pre>"},{"location":"code/configs/config_utils/","title":"yival.configs.config_utils","text":""},{"location":"code/configs/config_utils/#yival.configs.config_utils.load_and_validate_config","title":"<code>load_and_validate_config(config_filepath)</code>","text":"<p>Load and validate the experiment configuration directly from a specified filepath.</p> Source code in <code>src/yival/configs/config_utils.py</code> <pre><code>def load_and_validate_config(config_filepath: str) -&gt; ExperimentConfig:\n\"\"\"\n    Load and validate the experiment configuration directly from a specified filepath.\n    \"\"\"\n\n    # Load the configuration directly from the specified filepath\n    dict_config = OmegaConf.load(config_filepath)\n\n    # Convert the DictConfig to ExperimentConfig and cast it\n    config = cast(ExperimentConfig, OmegaConf.to_object(dict_config))\n\n    return config\n</code></pre>"},{"location":"code/data/base_reader/","title":"yival.data.base_reader","text":"<p>This module provides an abstract foundation for data readers.</p> <p>Data readers are responsible for reading data from various sources, and this module offers a base class to define and register new readers, retrieve existing ones, and fetch their configurations. The design encourages efficient parallel processing by reading data in chunks.</p>"},{"location":"code/data/base_reader/#yival.data.base_reader.BaseReader","title":"<code>BaseReader</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for all data readers.</p> <p>This class provides a blueprint for data readers and offers methods to register new readers, retrieve registered readers, and fetch their configurations.</p> <p>Attributes:</p> Name Type Description <code>_registry</code> <code>Dict[str, Dict[str, Any]]</code> <p>A registry to keep track of                                     data readers.</p> <code>default_config</code> <code>Optional[BaseReaderConfig]</code> <p>Default configuration for                                         the reader.</p> Source code in <code>src/yival/data/base_reader.py</code> <pre><code>class BaseReader(ABC):\n\"\"\"\n    Abstract base class for all data readers.\n\n    This class provides a blueprint for data readers and offers methods to\n    register new readers,\n    retrieve registered readers, and fetch their configurations.\n\n    Attributes:\n        _registry (Dict[str, Dict[str, Any]]): A registry to keep track of\n                                                data readers.\n        default_config (Optional[BaseReaderConfig]): Default configuration for\n                                                    the reader.\n    \"\"\"\n    _registry: Dict[str, Dict[str, Any]] = {}\n    default_config: Optional[BaseReaderConfig] = None\n\n    @classmethod\n    def register(\n        cls, name: str, config_cls: Optional[Type[BaseReaderConfig]] = None\n    ):\n\"\"\"Decorator to register new readers.\"\"\"\n\n        def inner(subclass: Type[BaseReader]):\n            cls._registry[name] = {\n                \"class\": subclass,\n                \"default_config\": subclass.default_config,\n                \"config_cls\": config_cls\n            }\n            return subclass\n\n        return inner\n\n    @classmethod\n    def get_reader(cls, name: str) -&gt; Optional[Type['BaseReader']]:\n\"\"\"Retrieve reader class from registry by its name.\"\"\"\n        reader_info = cls._registry.get(name, {})\n        return reader_info.get(\n            \"class\", None\n        ) if \"class\" in reader_info else None\n\n    @classmethod\n    def get_default_config(cls, name: str) -&gt; Optional[BaseReaderConfig]:\n\"\"\"Retrieve the default configuration of a reader by its name.\"\"\"\n        reader_info = cls._registry.get(name, {})\n        return reader_info.get(\n            \"default_config\", None\n        ) if \"default_config\" in reader_info else None\n\n    def __init__(self, config: BaseReaderConfig):\n        self.config = config\n\n    @classmethod\n    def get_config_class(cls, name: str) -&gt; Optional[Type[BaseReaderConfig]]:\n\"\"\"Retrieve the configuration class of a reader by its name.\"\"\"\n        reader_info = cls._registry.get(name, {})\n        return reader_info.get(\"config_cls\", None)\n\n    @classmethod\n    def register_reader(\n        cls,\n        name: str,\n        reader_cls: Type['BaseReader'],\n        config_cls: Optional[Type[BaseReaderConfig]] = None\n    ):\n\"\"\"\n        Register reader's subclass along with its default configuration and\n        config class.\n        \"\"\"\n        cls._registry[name] = {\n            \"class\": reader_cls,\n            \"default_config\": reader_cls.default_config,\n            \"config_cls\": config_cls\n        }\n\n    @abstractmethod\n    def read(self, path: str) -&gt; Iterator[List[InputData]]:\n\"\"\"\n        Read data from the given file path and return an iterator of lists\n        containing InputData.\n\n        This method is designed to read data in chunks for efficient parallel\n        processing. The chunk size is determined by the reader's configuration.\n\n        Args:\n            path (str): The path to the file containing data to be read.\n\n        Returns:\n            Iterator[List[InputData]]: An iterator yielding lists of InputData\n            objects.\n        \"\"\"\n\n    def generate_example_id(self, row_data: Dict[str, Any], path: str) -&gt; str:\n\"\"\"\n        Default function to generate an example_id for a given row of data.\n        \"\"\"\n        row_hash = hashlib.md5(str(row_data).encode()).hexdigest()\n        return f\"{path}_{row_hash}\"\n</code></pre>"},{"location":"code/data/base_reader/#yival.data.base_reader.BaseReader.generate_example_id","title":"<code>generate_example_id(row_data, path)</code>","text":"<p>Default function to generate an example_id for a given row of data.</p> Source code in <code>src/yival/data/base_reader.py</code> <pre><code>def generate_example_id(self, row_data: Dict[str, Any], path: str) -&gt; str:\n\"\"\"\n    Default function to generate an example_id for a given row of data.\n    \"\"\"\n    row_hash = hashlib.md5(str(row_data).encode()).hexdigest()\n    return f\"{path}_{row_hash}\"\n</code></pre>"},{"location":"code/data/base_reader/#yival.data.base_reader.BaseReader.get_config_class","title":"<code>get_config_class(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the configuration class of a reader by its name.</p> Source code in <code>src/yival/data/base_reader.py</code> <pre><code>@classmethod\ndef get_config_class(cls, name: str) -&gt; Optional[Type[BaseReaderConfig]]:\n\"\"\"Retrieve the configuration class of a reader by its name.\"\"\"\n    reader_info = cls._registry.get(name, {})\n    return reader_info.get(\"config_cls\", None)\n</code></pre>"},{"location":"code/data/base_reader/#yival.data.base_reader.BaseReader.get_default_config","title":"<code>get_default_config(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the default configuration of a reader by its name.</p> Source code in <code>src/yival/data/base_reader.py</code> <pre><code>@classmethod\ndef get_default_config(cls, name: str) -&gt; Optional[BaseReaderConfig]:\n\"\"\"Retrieve the default configuration of a reader by its name.\"\"\"\n    reader_info = cls._registry.get(name, {})\n    return reader_info.get(\n        \"default_config\", None\n    ) if \"default_config\" in reader_info else None\n</code></pre>"},{"location":"code/data/base_reader/#yival.data.base_reader.BaseReader.get_reader","title":"<code>get_reader(name)</code>  <code>classmethod</code>","text":"<p>Retrieve reader class from registry by its name.</p> Source code in <code>src/yival/data/base_reader.py</code> <pre><code>@classmethod\ndef get_reader(cls, name: str) -&gt; Optional[Type['BaseReader']]:\n\"\"\"Retrieve reader class from registry by its name.\"\"\"\n    reader_info = cls._registry.get(name, {})\n    return reader_info.get(\n        \"class\", None\n    ) if \"class\" in reader_info else None\n</code></pre>"},{"location":"code/data/base_reader/#yival.data.base_reader.BaseReader.read","title":"<code>read(path)</code>  <code>abstractmethod</code>","text":"<p>Read data from the given file path and return an iterator of lists containing InputData.</p> <p>This method is designed to read data in chunks for efficient parallel processing. The chunk size is determined by the reader's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file containing data to be read.</p> required <p>Returns:</p> Type Description <code>List[InputData]</code> <p>Iterator[List[InputData]]: An iterator yielding lists of InputData</p> <code>List[InputData]</code> <p>objects.</p> Source code in <code>src/yival/data/base_reader.py</code> <pre><code>@abstractmethod\ndef read(self, path: str) -&gt; Iterator[List[InputData]]:\n\"\"\"\n    Read data from the given file path and return an iterator of lists\n    containing InputData.\n\n    This method is designed to read data in chunks for efficient parallel\n    processing. The chunk size is determined by the reader's configuration.\n\n    Args:\n        path (str): The path to the file containing data to be read.\n\n    Returns:\n        Iterator[List[InputData]]: An iterator yielding lists of InputData\n        objects.\n    \"\"\"\n</code></pre>"},{"location":"code/data/base_reader/#yival.data.base_reader.BaseReader.register","title":"<code>register(name, config_cls=None)</code>  <code>classmethod</code>","text":"<p>Decorator to register new readers.</p> Source code in <code>src/yival/data/base_reader.py</code> <pre><code>@classmethod\ndef register(\n    cls, name: str, config_cls: Optional[Type[BaseReaderConfig]] = None\n):\n\"\"\"Decorator to register new readers.\"\"\"\n\n    def inner(subclass: Type[BaseReader]):\n        cls._registry[name] = {\n            \"class\": subclass,\n            \"default_config\": subclass.default_config,\n            \"config_cls\": config_cls\n        }\n        return subclass\n\n    return inner\n</code></pre>"},{"location":"code/data/base_reader/#yival.data.base_reader.BaseReader.register_reader","title":"<code>register_reader(name, reader_cls, config_cls=None)</code>  <code>classmethod</code>","text":"<p>Register reader's subclass along with its default configuration and config class.</p> Source code in <code>src/yival/data/base_reader.py</code> <pre><code>@classmethod\ndef register_reader(\n    cls,\n    name: str,\n    reader_cls: Type['BaseReader'],\n    config_cls: Optional[Type[BaseReaderConfig]] = None\n):\n\"\"\"\n    Register reader's subclass along with its default configuration and\n    config class.\n    \"\"\"\n    cls._registry[name] = {\n        \"class\": reader_cls,\n        \"default_config\": reader_cls.default_config,\n        \"config_cls\": config_cls\n    }\n</code></pre>"},{"location":"code/data_generators/base_data_generator/","title":"yival.data_generators.base_data_generator","text":"<p>This module provides a foundational architecture for programmatically generating data.</p> <p>Data generators are responsible for creating data programmatically based on certain configurations. The primary utility of these generators is in scenarios where synthetic or mock data is required, such as testing, simulations, and more. This module offers a base class that outlines the primary structure and functionalities of a data generator. It also provides methods to register new generators, retrieve existing ones, and fetch their configurations.</p>"},{"location":"code/data_generators/base_data_generator/#yival.data_generators.base_data_generator.BaseDataGenerator","title":"<code>BaseDataGenerator</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for all data generators.</p> <p>This class provides a blueprint for data generators and offers methods to register new generators, retrieve registered generators, and fetch their configurations.</p> <p>Attributes:</p> Name Type Description <code>_registry</code> <code>Dict[str, Dict[str, Any]]</code> <p>A registry to keep track of                                     data generators.</p> <code>default_config</code> <code>Optional[BaseDataGeneratorConfig]</code> <p>Default                         configuration for the generator.</p> Source code in <code>src/yival/data_generators/base_data_generator.py</code> <pre><code>class BaseDataGenerator(ABC):\n\"\"\"\n    Abstract base class for all data generators.\n\n    This class provides a blueprint for data generators and offers methods to\n    register new generators,\n    retrieve registered generators, and fetch their configurations.\n\n    Attributes:\n        _registry (Dict[str, Dict[str, Any]]): A registry to keep track of\n                                                data generators.\n        default_config (Optional[BaseDataGeneratorConfig]): Default\n                                    configuration for the generator.\n    \"\"\"\n\n    _registry: Dict[str, Dict[str, Any]] = {}\n    default_config: Optional[BaseDataGeneratorConfig] = None\n\n    @classmethod\n    def get_data_generator(cls,\n                           name: str) -&gt; Optional[Type['BaseDataGenerator']]:\n\"\"\"Retrieve data generator class from registry by its name.\"\"\"\n        return cls._registry.get(name, {}).get(\"class\")\n\n    @classmethod\n    def get_default_config(cls,\n                           name: str) -&gt; Optional[BaseDataGeneratorConfig]:\n\"\"\"Retrieve the default configuration of a data generator by its\n        name.\"\"\"\n        return cls._registry.get(name, {}).get(\"default_config\")\n\n    def __init__(self, config: BaseDataGeneratorConfig):\n        self.config = config\n\n    @classmethod\n    def get_config_class(cls,\n                         name: str) -&gt; Optional[Type[BaseDataGeneratorConfig]]:\n\"\"\"Retrieve the configuration class of a generator_info by its name.\"\"\"\n        return cls._registry.get(name, {}).get(\"config_cls\")\n\n    @classmethod\n    def register_data_generator(\n        cls,\n        name: str,\n        data_generator_cls: Type['BaseDataGenerator'],\n        config_cls: Optional[Type[BaseDataGeneratorConfig]] = None\n    ):\n\"\"\"\n        Register data generator class with the registry.\n        \"\"\"\n        cls._registry[name] = {\n            \"class\": data_generator_cls,\n            \"default_config\": data_generator_cls.default_config,\n            \"config_cls\": config_cls\n        }\n\n    @abstractmethod\n    def generate_examples(self) -&gt; Iterator[List[InputData]]:\n\"\"\"\n        Generate data examples and return an iterator of lists containing\n        InputData.\n\n        This method is designed to produce data programmatically. The number\n        and nature of data examples are determined by the generator's\n        configuration.\n\n        Returns:\n            Iterator[List[InputData]]: An iterator yielding lists of InputData\n            objects.\n        \"\"\"\n\n    def generate_example_id(self, content: str) -&gt; str:\n\"\"\"\n        Generate a unique identifier for a given content string.\n\n        Args:\n            content (str): The content for which an ID should be generated.\n\n        Returns:\n            str: A unique MD5 hash derived from the content.\n        \"\"\"\n        return hashlib.md5(content.encode()).hexdigest()\n</code></pre>"},{"location":"code/data_generators/base_data_generator/#yival.data_generators.base_data_generator.BaseDataGenerator.generate_example_id","title":"<code>generate_example_id(content)</code>","text":"<p>Generate a unique identifier for a given content string.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content for which an ID should be generated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A unique MD5 hash derived from the content.</p> Source code in <code>src/yival/data_generators/base_data_generator.py</code> <pre><code>def generate_example_id(self, content: str) -&gt; str:\n\"\"\"\n    Generate a unique identifier for a given content string.\n\n    Args:\n        content (str): The content for which an ID should be generated.\n\n    Returns:\n        str: A unique MD5 hash derived from the content.\n    \"\"\"\n    return hashlib.md5(content.encode()).hexdigest()\n</code></pre>"},{"location":"code/data_generators/base_data_generator/#yival.data_generators.base_data_generator.BaseDataGenerator.generate_examples","title":"<code>generate_examples()</code>  <code>abstractmethod</code>","text":"<p>Generate data examples and return an iterator of lists containing InputData.</p> <p>This method is designed to produce data programmatically. The number and nature of data examples are determined by the generator's configuration.</p> <p>Returns:</p> Type Description <code>List[InputData]</code> <p>Iterator[List[InputData]]: An iterator yielding lists of InputData</p> <code>List[InputData]</code> <p>objects.</p> Source code in <code>src/yival/data_generators/base_data_generator.py</code> <pre><code>@abstractmethod\ndef generate_examples(self) -&gt; Iterator[List[InputData]]:\n\"\"\"\n    Generate data examples and return an iterator of lists containing\n    InputData.\n\n    This method is designed to produce data programmatically. The number\n    and nature of data examples are determined by the generator's\n    configuration.\n\n    Returns:\n        Iterator[List[InputData]]: An iterator yielding lists of InputData\n        objects.\n    \"\"\"\n</code></pre>"},{"location":"code/data_generators/base_data_generator/#yival.data_generators.base_data_generator.BaseDataGenerator.get_config_class","title":"<code>get_config_class(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the configuration class of a generator_info by its name.</p> Source code in <code>src/yival/data_generators/base_data_generator.py</code> <pre><code>@classmethod\ndef get_config_class(cls,\n                     name: str) -&gt; Optional[Type[BaseDataGeneratorConfig]]:\n\"\"\"Retrieve the configuration class of a generator_info by its name.\"\"\"\n    return cls._registry.get(name, {}).get(\"config_cls\")\n</code></pre>"},{"location":"code/data_generators/base_data_generator/#yival.data_generators.base_data_generator.BaseDataGenerator.get_data_generator","title":"<code>get_data_generator(name)</code>  <code>classmethod</code>","text":"<p>Retrieve data generator class from registry by its name.</p> Source code in <code>src/yival/data_generators/base_data_generator.py</code> <pre><code>@classmethod\ndef get_data_generator(cls,\n                       name: str) -&gt; Optional[Type['BaseDataGenerator']]:\n\"\"\"Retrieve data generator class from registry by its name.\"\"\"\n    return cls._registry.get(name, {}).get(\"class\")\n</code></pre>"},{"location":"code/data_generators/base_data_generator/#yival.data_generators.base_data_generator.BaseDataGenerator.get_default_config","title":"<code>get_default_config(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the default configuration of a data generator by its name.</p> Source code in <code>src/yival/data_generators/base_data_generator.py</code> <pre><code>@classmethod\ndef get_default_config(cls,\n                       name: str) -&gt; Optional[BaseDataGeneratorConfig]:\n\"\"\"Retrieve the default configuration of a data generator by its\n    name.\"\"\"\n    return cls._registry.get(name, {}).get(\"default_config\")\n</code></pre>"},{"location":"code/data_generators/base_data_generator/#yival.data_generators.base_data_generator.BaseDataGenerator.register_data_generator","title":"<code>register_data_generator(name, data_generator_cls, config_cls=None)</code>  <code>classmethod</code>","text":"<p>Register data generator class with the registry.</p> Source code in <code>src/yival/data_generators/base_data_generator.py</code> <pre><code>@classmethod\ndef register_data_generator(\n    cls,\n    name: str,\n    data_generator_cls: Type['BaseDataGenerator'],\n    config_cls: Optional[Type[BaseDataGeneratorConfig]] = None\n):\n\"\"\"\n    Register data generator class with the registry.\n    \"\"\"\n    cls._registry[name] = {\n        \"class\": data_generator_cls,\n        \"default_config\": data_generator_cls.default_config,\n        \"config_cls\": config_cls\n    }\n</code></pre>"},{"location":"code/evaluators/base_evaluator/","title":"yival.evaluators.base_evaluator","text":"<p>Evaluators Module.</p> <p>This module contains the base class and common methods for evaluators used in experiments. Evaluators are essential components in the system that interpret the results of experiments and provide quantitative or qualitative feedback. Specific evaluators are expected to inherit from the base class and implement custom evaluation logic as needed.</p>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator","title":"<code>BaseEvaluator</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for all evaluators.</p> <p>This class provides the basic structure and methods for evaluators. Specific evaluators should inherit from this class and implement the necessary methods.</p> Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>class BaseEvaluator(ABC):\n\"\"\"\n    Base class for all evaluators.\n\n    This class provides the basic structure and methods for evaluators.\n    Specific evaluators should inherit from this class and implement the\n    necessary methods.\n\n    \"\"\"\n    _registry: Dict[str, Dict[str, Any]] = {}\n    default_config: Optional[BaseEvaluatorConfig] = None\n\n    def __init__(self, config: BaseEvaluatorConfig):\n\"\"\"\n        Initialize the evaluator with its configuration.\n\n        Args:\n            config (BaseEvaluatorConfig): The configuration for the evaluator.\n\n        \"\"\"\n        self.config = config\n\n    @classmethod\n    def register(cls, name: str):\n\"\"\"Decorator to register new evaluators.\"\"\"\n\n        def inner(subclass: Type[BaseEvaluator]):\n            cls._registry[name] = {\n                \"class\": subclass,\n                \"default_config\": subclass.default_config\n            }\n            return subclass\n\n        return inner\n\n    @classmethod\n    def get_evaluator(cls, name: str) -&gt; Optional[Type['BaseEvaluator']]:\n\"\"\"Retrieve evaluator class from registry by its name.\"\"\"\n        evaluator_info = cls._registry.get(name, {})\n        return evaluator_info.get(\n            \"class\", None\n        ) if \"class\" in evaluator_info else None\n\n    @classmethod\n    def get_default_config(cls, name: str) -&gt; Optional[BaseEvaluatorConfig]:\n\"\"\"Retrieve the default configuration of an evaluator by its name.\"\"\"\n        evaluator_info = cls._registry.get(name, {})\n        return evaluator_info.get(\n            \"default_config\", None\n        ) if \"default_config\" in evaluator_info else None\n\n    @classmethod\n    def register_evaluator(\n        cls,\n        name: str,\n        reader_cls: Type[T_Evaluator],\n        config_cls: Optional[Type[BaseEvaluatorConfig]] = None\n    ):\n        cls._registry[name] = {\n            \"class\": reader_cls,\n            \"default_config\": reader_cls.default_config,\n            \"config_cls\": config_cls\n        }\n\n    @classmethod\n    def get_config_class(cls,\n                         name: str) -&gt; Optional[Type[BaseEvaluatorConfig]]:\n\"\"\"Retrieve the configuration class of a reader by its name.\"\"\"\n        reader_info = cls._registry.get(name, {})\n        return reader_info.get(\"config_cls\", None)\n\n    def evaluate(self, experiment_result: ExperimentResult) -&gt; EvaluatorOutput:\n\"\"\"\n        Evaluate the experiment result and produce an evaluator output.\n\n        Args:\n            experiment_result (ExperimentResult): The result of an experiment\n            to be evaluated.\n\n        Returns:\n            EvaluatorOutput: The result of the evaluation.\n        \"\"\"\n        return EvaluatorOutput(\"evaluate\", \"evaluate\")\n\n    def evaluate_comparison(\n        self, group_data: List[ExperimentResult]\n    ) -&gt; EvaluatorOutput:\n\"\"\"\n        Evaluate and compare a list of experiment results.\n\n        This method is designed to evaluate multiple experiment results\n        together, allowing for comparisons and potentially identifying trends,\n        anomalies, or other patterns in the set of results.\n\n        Args:\n            group_data (List[ExperimentResult]): A list of experiment results\n            to be evaluated together.\n        Returns:\n            EvaluatorOutput: The result of the evaluation.\n\n        Note:\n            Implementations of this method in subclasses should handle the\n            specifics of how multiple experiments are evaluated and compared.\n        \"\"\"\n        return EvaluatorOutput(\"evaluate\", \"evaluate\")\n\n    def evaluate_based_on_all_results(\n        self, experiment: List[Experiment]\n    ) -&gt; None:\n\"\"\"\n        Evaluate based on the entirety of experiment results.\n\n        This method evaluates an entire list of experiments, potentially taking \n        into account all available data to produce a comprehensive evaluation.\n\n        Args:\n            experiment (List[Experiment]): A list of all experiments to be\n            evaluated.\n\n        Note:\n            Implementations of this method in subclasses should determine how\n            to best utilize all available experiment data for evaluation.\n        \"\"\"\n</code></pre>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the evaluator with its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BaseEvaluatorConfig</code> <p>The configuration for the evaluator.</p> required Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>def __init__(self, config: BaseEvaluatorConfig):\n\"\"\"\n    Initialize the evaluator with its configuration.\n\n    Args:\n        config (BaseEvaluatorConfig): The configuration for the evaluator.\n\n    \"\"\"\n    self.config = config\n</code></pre>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator.evaluate","title":"<code>evaluate(experiment_result)</code>","text":"<p>Evaluate the experiment result and produce an evaluator output.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_result</code> <code>ExperimentResult</code> <p>The result of an experiment</p> required <p>Returns:</p> Name Type Description <code>EvaluatorOutput</code> <code>EvaluatorOutput</code> <p>The result of the evaluation.</p> Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>def evaluate(self, experiment_result: ExperimentResult) -&gt; EvaluatorOutput:\n\"\"\"\n    Evaluate the experiment result and produce an evaluator output.\n\n    Args:\n        experiment_result (ExperimentResult): The result of an experiment\n        to be evaluated.\n\n    Returns:\n        EvaluatorOutput: The result of the evaluation.\n    \"\"\"\n    return EvaluatorOutput(\"evaluate\", \"evaluate\")\n</code></pre>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator.evaluate_based_on_all_results","title":"<code>evaluate_based_on_all_results(experiment)</code>","text":"<p>Evaluate based on the entirety of experiment results.</p> <p>This method evaluates an entire list of experiments, potentially taking  into account all available data to produce a comprehensive evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>experiment</code> <code>List[Experiment]</code> <p>A list of all experiments to be</p> required Note <p>Implementations of this method in subclasses should determine how to best utilize all available experiment data for evaluation.</p> Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>def evaluate_based_on_all_results(\n    self, experiment: List[Experiment]\n) -&gt; None:\n\"\"\"\n    Evaluate based on the entirety of experiment results.\n\n    This method evaluates an entire list of experiments, potentially taking \n    into account all available data to produce a comprehensive evaluation.\n\n    Args:\n        experiment (List[Experiment]): A list of all experiments to be\n        evaluated.\n\n    Note:\n        Implementations of this method in subclasses should determine how\n        to best utilize all available experiment data for evaluation.\n    \"\"\"\n</code></pre>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator.evaluate_comparison","title":"<code>evaluate_comparison(group_data)</code>","text":"<p>Evaluate and compare a list of experiment results.</p> <p>This method is designed to evaluate multiple experiment results together, allowing for comparisons and potentially identifying trends, anomalies, or other patterns in the set of results.</p> <p>Parameters:</p> Name Type Description Default <code>group_data</code> <code>List[ExperimentResult]</code> <p>A list of experiment results</p> required <p>Returns:</p> Name Type Description <code>EvaluatorOutput</code> <code>EvaluatorOutput</code> <p>The result of the evaluation.</p> Note <p>Implementations of this method in subclasses should handle the specifics of how multiple experiments are evaluated and compared.</p> Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>def evaluate_comparison(\n    self, group_data: List[ExperimentResult]\n) -&gt; EvaluatorOutput:\n\"\"\"\n    Evaluate and compare a list of experiment results.\n\n    This method is designed to evaluate multiple experiment results\n    together, allowing for comparisons and potentially identifying trends,\n    anomalies, or other patterns in the set of results.\n\n    Args:\n        group_data (List[ExperimentResult]): A list of experiment results\n        to be evaluated together.\n    Returns:\n        EvaluatorOutput: The result of the evaluation.\n\n    Note:\n        Implementations of this method in subclasses should handle the\n        specifics of how multiple experiments are evaluated and compared.\n    \"\"\"\n    return EvaluatorOutput(\"evaluate\", \"evaluate\")\n</code></pre>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator.get_config_class","title":"<code>get_config_class(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the configuration class of a reader by its name.</p> Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>@classmethod\ndef get_config_class(cls,\n                     name: str) -&gt; Optional[Type[BaseEvaluatorConfig]]:\n\"\"\"Retrieve the configuration class of a reader by its name.\"\"\"\n    reader_info = cls._registry.get(name, {})\n    return reader_info.get(\"config_cls\", None)\n</code></pre>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator.get_default_config","title":"<code>get_default_config(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the default configuration of an evaluator by its name.</p> Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>@classmethod\ndef get_default_config(cls, name: str) -&gt; Optional[BaseEvaluatorConfig]:\n\"\"\"Retrieve the default configuration of an evaluator by its name.\"\"\"\n    evaluator_info = cls._registry.get(name, {})\n    return evaluator_info.get(\n        \"default_config\", None\n    ) if \"default_config\" in evaluator_info else None\n</code></pre>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator.get_evaluator","title":"<code>get_evaluator(name)</code>  <code>classmethod</code>","text":"<p>Retrieve evaluator class from registry by its name.</p> Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>@classmethod\ndef get_evaluator(cls, name: str) -&gt; Optional[Type['BaseEvaluator']]:\n\"\"\"Retrieve evaluator class from registry by its name.\"\"\"\n    evaluator_info = cls._registry.get(name, {})\n    return evaluator_info.get(\n        \"class\", None\n    ) if \"class\" in evaluator_info else None\n</code></pre>"},{"location":"code/evaluators/base_evaluator/#yival.evaluators.base_evaluator.BaseEvaluator.register","title":"<code>register(name)</code>  <code>classmethod</code>","text":"<p>Decorator to register new evaluators.</p> Source code in <code>src/yival/evaluators/base_evaluator.py</code> <pre><code>@classmethod\ndef register(cls, name: str):\n\"\"\"Decorator to register new evaluators.\"\"\"\n\n    def inner(subclass: Type[BaseEvaluator]):\n        cls._registry[name] = {\n            \"class\": subclass,\n            \"default_config\": subclass.default_config\n        }\n        return subclass\n\n    return inner\n</code></pre>"},{"location":"code/result_selectors/selection_strategy/","title":"yival.result_selectors.selection_strategy","text":"<p>Selection Strategy Module.</p> <p>This module defines an abstract base class for selection strategies. A selection strategy  determines how to select or prioritize specific experiments, scenarios, or configurations based on certain criteria.</p>"},{"location":"code/result_selectors/selection_strategy/#yival.result_selectors.selection_strategy.SelectionStrategy","title":"<code>SelectionStrategy</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for selection strategies.</p> Source code in <code>src/yival/result_selectors/selection_strategy.py</code> <pre><code>class SelectionStrategy(ABC):\n\"\"\"\n    Abstract base class for selection strategies.\n    \"\"\"\n    _registry: Dict[str, Dict[str, Any]] = {}\n    default_config: Optional[BaseConfig] = None\n\n    @abstractmethod\n    def select(self, experiment: Experiment) -&gt; SelectionOutput:\n        pass\n\n    @classmethod\n    def register_strategy(\n        cls,\n        name: str,\n        strategy_cls: Type['SelectionStrategy'],\n        config_cls: Optional[Type[BaseConfig]] = None\n    ):\n        cls._registry[name] = {\n            \"class\": strategy_cls,\n            \"default_config\": strategy_cls.default_config,\n            \"config_cls\": config_cls\n        }\n\n    @classmethod\n    def get_strategy(cls, name: str) -&gt; Optional[Type['SelectionStrategy']]:\n\"\"\"Retrieve strategy class from registry by its name.\"\"\"\n        strategy_info = cls._registry.get(name, {})\n        return strategy_info.get(\n            \"class\", None\n        ) if \"class\" in strategy_info else None\n\n    @classmethod\n    def get_default_config(cls, name: str) -&gt; Optional[BaseConfig]:\n\"\"\"Retrieve the default configuration of a strategy by its name.\"\"\"\n        strategy_info = cls._registry.get(name, {})\n        return strategy_info.get(\n            \"default_config\", None\n        ) if \"default_config\" in strategy_info else None\n\n    @classmethod\n    def get_config_class(cls, name: str) -&gt; Optional[Type[BaseConfig]]:\n        strategy_info = cls._registry.get(name, {})\n        return strategy_info.get(\"config_cls\", None)\n\n    def __init__(self, config: BaseConfig):\n        self.config = config\n</code></pre>"},{"location":"code/result_selectors/selection_strategy/#yival.result_selectors.selection_strategy.SelectionStrategy.get_default_config","title":"<code>get_default_config(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the default configuration of a strategy by its name.</p> Source code in <code>src/yival/result_selectors/selection_strategy.py</code> <pre><code>@classmethod\ndef get_default_config(cls, name: str) -&gt; Optional[BaseConfig]:\n\"\"\"Retrieve the default configuration of a strategy by its name.\"\"\"\n    strategy_info = cls._registry.get(name, {})\n    return strategy_info.get(\n        \"default_config\", None\n    ) if \"default_config\" in strategy_info else None\n</code></pre>"},{"location":"code/result_selectors/selection_strategy/#yival.result_selectors.selection_strategy.SelectionStrategy.get_strategy","title":"<code>get_strategy(name)</code>  <code>classmethod</code>","text":"<p>Retrieve strategy class from registry by its name.</p> Source code in <code>src/yival/result_selectors/selection_strategy.py</code> <pre><code>@classmethod\ndef get_strategy(cls, name: str) -&gt; Optional[Type['SelectionStrategy']]:\n\"\"\"Retrieve strategy class from registry by its name.\"\"\"\n    strategy_info = cls._registry.get(name, {})\n    return strategy_info.get(\n        \"class\", None\n    ) if \"class\" in strategy_info else None\n</code></pre>"},{"location":"code/states/experiment_state/","title":"yival.states.experiment_state","text":"<p>Experiment State Module.</p> <p>This module defines the <code>ExperimentState</code> class to manage the state of active experiments and their variations. The state facilitates the retrieval and management of variations associated with different experiments, providing a mechanism to cycle through the variations and track the experiment's state.</p>"},{"location":"code/states/experiment_state/#yival.states.experiment_state.ExperimentState","title":"<code>ExperimentState</code>","text":"<p>Represents the state for managing experiment variations.</p> <p>This class maintains the state of active experiments and their variations.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>bool</code> <p>Indicates if the experiment is currently active.</p> <code>current_variations</code> <code>Dict[str, List[Any]]</code> <p>A dictionary where keys are</p> <code>counters</code> <code>Dict[str, int]</code> <p>A counter for each experiment name to</p> Methods <p>get_next_variation(name: str) -&gt; Optional[Any]:     Depending on the global ExperimentState's activity status,     retrieves the next variation for the associated experiment name.     If the state is inactive or no variations are found, returns None.</p> Source code in <code>src/yival/states/experiment_state.py</code> <pre><code>class ExperimentState:\n\"\"\"\n    Represents the state for managing experiment variations.\n\n    This class maintains the state of active experiments and their variations.\n\n    Attributes:\n        active (bool): Indicates if the experiment is currently active.\n        current_variations (Dict[str, List[Any]]): A dictionary where keys are\n        experiment names and values are lists of variations.\n        counters (Dict[str, int]): A counter for each experiment name to\n        rotate through its variations.\n\n    Methods:\n        get_next_variation(name: str) -&gt; Optional[Any]:\n            Depending on the global ExperimentState's activity status,\n            retrieves the next variation for the associated experiment name.\n            If the state is inactive or no variations are found, returns None.\n    \"\"\"\n\n    _shared_instance = None\n\n    @staticmethod\n    def get_instance():\n        if ExperimentState._shared_instance is None:\n            ExperimentState._shared_instance = ExperimentState()\n        return ExperimentState._shared_instance\n\n    def __init__(self) -&gt; None:\n        self.active: bool = False\n        self.current_variations: Dict[str, List[Any]] = {}\n        self.counters: Dict[str, int] = defaultdict(int)\n        self.config: Optional[ExperimentConfig] = None\n\n    def get_next_variation(self, name: str) -&gt; Optional[Any]:\n        variations = self.current_variations.get(name, [])\n        if self.counters[name] &lt; len(variations):\n            variation = variations[self.counters[name]]\n            self.counters[name] += 1\n            return variation\n        return None\n\n    def get_all_variation_combinations(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Returns a list of dictionaries where each dictionary \n        represents a unique combination of variations.\n        \"\"\"\n        all_variations = []\n        for name, variations in self.current_variations.items():\n            all_variations.append([(name, variation)\n                                   for variation in variations])\n        combinations = []\n        for combo in product(*all_variations):\n            combo_dict = {name: variation for name, variation in combo}\n            combinations.append(combo_dict)\n        return combinations\n\n    def initialize_variations_from_config(self) -&gt; None:\n\"\"\"\n        Initializes the experiment variations using the provided\n        ExperimentConfig.\n        \"\"\"\n        if self.config and self.config.variations:\n            for wrapper_config in self.config.variations:\n                if not isinstance(wrapper_config, dict):\n                    wrapper_config = wrapper_config.asdict()  # type: ignore\n                if \"variations\" in wrapper_config:  # type: ignore\n                    variations = [\n                        var_variation[\"instantiated_value\"] for var_variation\n                        in wrapper_config[\"variations\"]  # type: ignore\n                    ]\n                    self.set_variations_for_experiment(\n                        wrapper_config[\"name\"],  # type: ignore\n                        variations\n                    )\n                if \"generator_name\" in wrapper_config:  # type: ignore\n                    generator_cls = BaseVariationGenerator.get_variation_generator(\n                        wrapper_config[\"generator_name\"]  # type: ignore\n                    )\n                    config_cls = BaseVariationGenerator.get_config_class(\n                        wrapper_config[\"generator_name\"]  # type: ignore\n                    )\n                    if generator_cls:\n                        if config_cls:\n                            if \"generator_config\" in wrapper_config:  # type: ignore\n                                if isinstance(\n                                    wrapper_config[\"generator_config\"\n                                                   ],  # type: ignore\n                                    dict\n                                ):\n                                    config_data = wrapper_config[  # type: ignore\n                                        \"generator_config\"]\n                                else:\n                                    config_data = wrapper_config[  # type: ignore\n                                        \"generator_config\"].asdict()\n                                config_instance = config_cls(**config_data)\n                            else:\n                                config_instance = config_cls()\n                            generator_instance = generator_cls(config_instance)\n                        else:\n                            generator_instance = generator_cls(\n                                BaseVariationGeneratorConfig()\n                            )\n                        vs = []\n                        for vars in generator_instance.generate_variations():\n                            for var in vars:\n                                vs.append(var.instantiated_value)\n                        self.set_variations_for_experiment(\n                            wrapper_config[\"name\"],  # type: ignore\n                            vs\n                        )\n\n    def set_variations_for_experiment(\n        self, name: str, variations: Union[List[Any], Iterator[Any]]\n    ) -&gt; None:\n        existing_variations = self.current_variations.get(name, [])\n        existing_variations.extend(variations)\n        self.current_variations[name] = existing_variations\n\n    def clear_variations_for_experiment(self) -&gt; None:\n        self.current_variations.clear()\n\n    def set_experiment_config(self, config: Any) -&gt; None:\n        if isinstance(config, dict):\n            self.config = ExperimentConfig(**config)\n        else:\n            self.config = config\n        self.initialize_variations_from_config()\n\n    def set_specific_variation(self, name: str, variation: Any) -&gt; None:\n\"\"\"\n        Sets a specific variation for an experiment without cycling through\n        the variations.\n        \"\"\"\n        self.current_variations[name] = [variation]\n        self.counters[name] = 0\n</code></pre>"},{"location":"code/states/experiment_state/#yival.states.experiment_state.ExperimentState.get_all_variation_combinations","title":"<code>get_all_variation_combinations()</code>","text":"<p>Returns a list of dictionaries where each dictionary  represents a unique combination of variations.</p> Source code in <code>src/yival/states/experiment_state.py</code> <pre><code>def get_all_variation_combinations(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Returns a list of dictionaries where each dictionary \n    represents a unique combination of variations.\n    \"\"\"\n    all_variations = []\n    for name, variations in self.current_variations.items():\n        all_variations.append([(name, variation)\n                               for variation in variations])\n    combinations = []\n    for combo in product(*all_variations):\n        combo_dict = {name: variation for name, variation in combo}\n        combinations.append(combo_dict)\n    return combinations\n</code></pre>"},{"location":"code/states/experiment_state/#yival.states.experiment_state.ExperimentState.initialize_variations_from_config","title":"<code>initialize_variations_from_config()</code>","text":"<p>Initializes the experiment variations using the provided ExperimentConfig.</p> Source code in <code>src/yival/states/experiment_state.py</code> <pre><code>def initialize_variations_from_config(self) -&gt; None:\n\"\"\"\n    Initializes the experiment variations using the provided\n    ExperimentConfig.\n    \"\"\"\n    if self.config and self.config.variations:\n        for wrapper_config in self.config.variations:\n            if not isinstance(wrapper_config, dict):\n                wrapper_config = wrapper_config.asdict()  # type: ignore\n            if \"variations\" in wrapper_config:  # type: ignore\n                variations = [\n                    var_variation[\"instantiated_value\"] for var_variation\n                    in wrapper_config[\"variations\"]  # type: ignore\n                ]\n                self.set_variations_for_experiment(\n                    wrapper_config[\"name\"],  # type: ignore\n                    variations\n                )\n            if \"generator_name\" in wrapper_config:  # type: ignore\n                generator_cls = BaseVariationGenerator.get_variation_generator(\n                    wrapper_config[\"generator_name\"]  # type: ignore\n                )\n                config_cls = BaseVariationGenerator.get_config_class(\n                    wrapper_config[\"generator_name\"]  # type: ignore\n                )\n                if generator_cls:\n                    if config_cls:\n                        if \"generator_config\" in wrapper_config:  # type: ignore\n                            if isinstance(\n                                wrapper_config[\"generator_config\"\n                                               ],  # type: ignore\n                                dict\n                            ):\n                                config_data = wrapper_config[  # type: ignore\n                                    \"generator_config\"]\n                            else:\n                                config_data = wrapper_config[  # type: ignore\n                                    \"generator_config\"].asdict()\n                            config_instance = config_cls(**config_data)\n                        else:\n                            config_instance = config_cls()\n                        generator_instance = generator_cls(config_instance)\n                    else:\n                        generator_instance = generator_cls(\n                            BaseVariationGeneratorConfig()\n                        )\n                    vs = []\n                    for vars in generator_instance.generate_variations():\n                        for var in vars:\n                            vs.append(var.instantiated_value)\n                    self.set_variations_for_experiment(\n                        wrapper_config[\"name\"],  # type: ignore\n                        vs\n                    )\n</code></pre>"},{"location":"code/states/experiment_state/#yival.states.experiment_state.ExperimentState.set_specific_variation","title":"<code>set_specific_variation(name, variation)</code>","text":"<p>Sets a specific variation for an experiment without cycling through the variations.</p> Source code in <code>src/yival/states/experiment_state.py</code> <pre><code>def set_specific_variation(self, name: str, variation: Any) -&gt; None:\n\"\"\"\n    Sets a specific variation for an experiment without cycling through\n    the variations.\n    \"\"\"\n    self.current_variations[name] = [variation]\n    self.counters[name] = 0\n</code></pre>"},{"location":"code/variation_generators/base_variation_generator/","title":"yival.variation_generators.base_variation_generator","text":"<p>Variation Generator Base Module.</p> <p>This module defines the <code>BaseVariationGenerator</code> class, an abstract base class for all variation generators. A variation generator is responsible for producing a sequence of variations to be used in experiments. The variations could represent different configurations, parameter settings, or other factors that should be tested in the context of an experiment. Subclasses of this base class should implement the specific logic for generating the desired variations.</p>"},{"location":"code/variation_generators/base_variation_generator/#yival.variation_generators.base_variation_generator.BaseVariationGenerator","title":"<code>BaseVariationGenerator</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for all variation variation.</p> Source code in <code>src/yival/variation_generators/base_variation_generator.py</code> <pre><code>class BaseVariationGenerator(ABC):\n\"\"\"\n    Abstract base class for all variation variation.\n    \"\"\"\n    _registry: Dict[str, Dict[str, Any]] = {}\n    default_config: Optional[BaseVariationGeneratorConfig] = None\n\n    @classmethod\n    def get_variation_generator(\n        cls, name: str\n    ) -&gt; Optional[Type['BaseVariationGenerator']]:\n\"\"\"Retrieve variation generator class from registry by its name.\"\"\"\n        generator_info = cls._registry.get(name, {})\n        return generator_info.get(\n            \"class\", None\n        ) if \"class\" in generator_info else None\n\n    @classmethod\n    def get_default_config(\n        cls, name: str\n    ) -&gt; Optional[BaseVariationGeneratorConfig]:\n\"\"\"Retrieve the default configuration of a variation generator by its\n        name.\"\"\"\n        generator_info = cls._registry.get(name, {})\n        return generator_info.get(\n            \"default_config\", None\n        ) if \"default_config\" in generator_info else None\n\n    def __init__(self, config: BaseVariationGeneratorConfig):\n        self.config = config\n\n    @classmethod\n    def get_config_class(\n        cls, name: str\n    ) -&gt; Optional[Type[BaseVariationGeneratorConfig]]:\n\"\"\"Retrieve the configuration class of a generator_info by its name.\"\"\"\n        generator_info = cls._registry.get(name, {})\n        return generator_info.get(\"config_cls\", None)\n\n    @classmethod\n    def register_variation_generator(\n        cls,\n        name: str,\n        variation_generator_cls: Type['BaseVariationGenerator'],\n        config_cls: Optional[Type[BaseVariationGeneratorConfig]] = None\n    ):\n        cls._registry[name] = {\n            \"class\": variation_generator_cls,\n            \"default_config\": variation_generator_cls.default_config,\n            \"config_cls\": config_cls\n        }\n\n    @abstractmethod\n    def generate_variations(self) -&gt; Iterator[List[WrapperVariation]]:\n\"\"\"\n        Generate a sequence of variations to be used in experiments.\n\n        This method should yield lists of variations, with each list typically\n        representing a set or batch of variations to be used in a single\n        experiment or iteration.\n\n        Returns:\n            Iterator[List[WrapperVariation]]: An iterator yielding lists of\n            WrapperVariation objects.\n\n        Note:\n            The specific logic for generating variations should be implemented\n            by subclasses.\n        \"\"\"\n</code></pre>"},{"location":"code/variation_generators/base_variation_generator/#yival.variation_generators.base_variation_generator.BaseVariationGenerator.generate_variations","title":"<code>generate_variations()</code>  <code>abstractmethod</code>","text":"<p>Generate a sequence of variations to be used in experiments.</p> <p>This method should yield lists of variations, with each list typically representing a set or batch of variations to be used in a single experiment or iteration.</p> <p>Returns:</p> Type Description <code>List[WrapperVariation]</code> <p>Iterator[List[WrapperVariation]]: An iterator yielding lists of</p> <code>List[WrapperVariation]</code> <p>WrapperVariation objects.</p> Note <p>The specific logic for generating variations should be implemented by subclasses.</p> Source code in <code>src/yival/variation_generators/base_variation_generator.py</code> <pre><code>@abstractmethod\ndef generate_variations(self) -&gt; Iterator[List[WrapperVariation]]:\n\"\"\"\n    Generate a sequence of variations to be used in experiments.\n\n    This method should yield lists of variations, with each list typically\n    representing a set or batch of variations to be used in a single\n    experiment or iteration.\n\n    Returns:\n        Iterator[List[WrapperVariation]]: An iterator yielding lists of\n        WrapperVariation objects.\n\n    Note:\n        The specific logic for generating variations should be implemented\n        by subclasses.\n    \"\"\"\n</code></pre>"},{"location":"code/variation_generators/base_variation_generator/#yival.variation_generators.base_variation_generator.BaseVariationGenerator.get_config_class","title":"<code>get_config_class(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the configuration class of a generator_info by its name.</p> Source code in <code>src/yival/variation_generators/base_variation_generator.py</code> <pre><code>@classmethod\ndef get_config_class(\n    cls, name: str\n) -&gt; Optional[Type[BaseVariationGeneratorConfig]]:\n\"\"\"Retrieve the configuration class of a generator_info by its name.\"\"\"\n    generator_info = cls._registry.get(name, {})\n    return generator_info.get(\"config_cls\", None)\n</code></pre>"},{"location":"code/variation_generators/base_variation_generator/#yival.variation_generators.base_variation_generator.BaseVariationGenerator.get_default_config","title":"<code>get_default_config(name)</code>  <code>classmethod</code>","text":"<p>Retrieve the default configuration of a variation generator by its name.</p> Source code in <code>src/yival/variation_generators/base_variation_generator.py</code> <pre><code>@classmethod\ndef get_default_config(\n    cls, name: str\n) -&gt; Optional[BaseVariationGeneratorConfig]:\n\"\"\"Retrieve the default configuration of a variation generator by its\n    name.\"\"\"\n    generator_info = cls._registry.get(name, {})\n    return generator_info.get(\n        \"default_config\", None\n    ) if \"default_config\" in generator_info else None\n</code></pre>"},{"location":"code/variation_generators/base_variation_generator/#yival.variation_generators.base_variation_generator.BaseVariationGenerator.get_variation_generator","title":"<code>get_variation_generator(name)</code>  <code>classmethod</code>","text":"<p>Retrieve variation generator class from registry by its name.</p> Source code in <code>src/yival/variation_generators/base_variation_generator.py</code> <pre><code>@classmethod\ndef get_variation_generator(\n    cls, name: str\n) -&gt; Optional[Type['BaseVariationGenerator']]:\n\"\"\"Retrieve variation generator class from registry by its name.\"\"\"\n    generator_info = cls._registry.get(name, {})\n    return generator_info.get(\n        \"class\", None\n    ) if \"class\" in generator_info else None\n</code></pre>"},{"location":"code/wrappers/base_wrapper/","title":"yival.wrappers.base_wrapper","text":"<p>Wrapper Base Module.</p> <p>This module introduces the <code>BaseWrapper</code> class, which serves as the fundamental structure for wrappers in the experimental framework. Wrappers manage experiment variations based on the global experiment state. They are crucial components to control and monitor different variations during an experiment's lifecycle.</p>"},{"location":"code/wrappers/base_wrapper/#yival.wrappers.base_wrapper.BaseWrapper","title":"<code>BaseWrapper</code>","text":"<p>Base class for wrappers that manage experiment variations based on the global experiment state.</p> <p>This class provides the fundamental structure and methods for wrappers. Specific wrappers should inherit from this class and implement the necessary methods.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the wrapper.</p> <code>experiment_state</code> <code>ExperimentState</code> <p>The global state of the experiment.</p> <code>config</code> <code>BaseWrapperConfig</code> <p>The configuration for the wrapper.</p> Source code in <code>src/yival/wrappers/base_wrapper.py</code> <pre><code>class BaseWrapper:\n\"\"\"\n    Base class for wrappers that manage experiment variations based on the\n    global experiment state.\n\n    This class provides the fundamental structure and methods for wrappers.\n    Specific wrappers should inherit from this class and implement the\n    necessary methods.\n\n    Attributes:\n        name (str): The name of the wrapper.\n        experiment_state (ExperimentState): The global state of the experiment.\n        config (BaseWrapperConfig): The configuration for the wrapper.\n    \"\"\"\n    _registry: Dict[str, Dict[str, Any]] = {}\n    default_config: Optional[BaseWrapperConfig] = None\n\n    @classmethod\n    def decorator_register(cls, name: str):\n\"\"\"Decorator to register new wrappers.\"\"\"\n\n        def inner(subclass: Type[BaseWrapper]):\n            cls._registry[name] = {\n                \"class\": subclass,\n                \"default_config\": subclass.default_config\n            }\n            return subclass\n\n        return inner\n\n    def __init__(\n        self, name: str, config: Optional[BaseWrapperConfig] = None\n    ) -&gt; None:\n        self.name = name\n        self.experiment_state = ExperimentState.get_instance()\n        self.config = config\n\n    def get_variation(self) -&gt; Optional[Any]:\n\"\"\"\n        Retrieve the next variation for the experiment based on the wrapper's\n        name.\n\n        Returns:\n            Optional[Any]: The next variation if the experiment is active,\n            otherwise None.\n        \"\"\"\n        if self.experiment_state.active:\n            return self.experiment_state.get_next_variation(self.name)\n        return None\n\n    @classmethod\n    def get_wrapper(cls, name: str) -&gt; Optional[Type['BaseWrapper']]:\n        return cls._registry.get(name, {}).get(\"class\")\n\n    @classmethod\n    def get_default_config(cls, name: str) -&gt; Optional[BaseWrapperConfig]:\n        return cls._registry.get(name, {}).get(\"default_config\")\n\n    @classmethod\n    def get_config_class(cls, name: str) -&gt; Optional[Type[BaseWrapperConfig]]:\n        return cls._registry.get(name, {}).get(\"config_cls\")\n\n    def get_active_config(self, name: str) -&gt; Optional[BaseWrapperConfig]:\n        if self.experiment_state.active and self.experiment_state.config.wrapper_configs:\n            config = self.experiment_state.config.wrapper_configs.get(name)\n            if config:\n                config_cls = BaseWrapper.get_config_class(name)\n                if config_cls:\n                    return config_cls(**config.asdict())\n        return None\n\n    @classmethod\n    def register_wrapper(\n        cls,\n        name: str,\n        wrapper_cls: Type['BaseWrapper'],\n        config_cls: Optional[Type[BaseWrapperConfig]] = None\n    ):\n        cls._registry[name] = {\n            \"class\": wrapper_cls,\n            \"default_config\": wrapper_cls.default_config,\n            \"config_cls\": config_cls\n        }\n</code></pre>"},{"location":"code/wrappers/base_wrapper/#yival.wrappers.base_wrapper.BaseWrapper.decorator_register","title":"<code>decorator_register(name)</code>  <code>classmethod</code>","text":"<p>Decorator to register new wrappers.</p> Source code in <code>src/yival/wrappers/base_wrapper.py</code> <pre><code>@classmethod\ndef decorator_register(cls, name: str):\n\"\"\"Decorator to register new wrappers.\"\"\"\n\n    def inner(subclass: Type[BaseWrapper]):\n        cls._registry[name] = {\n            \"class\": subclass,\n            \"default_config\": subclass.default_config\n        }\n        return subclass\n\n    return inner\n</code></pre>"},{"location":"code/wrappers/base_wrapper/#yival.wrappers.base_wrapper.BaseWrapper.get_variation","title":"<code>get_variation()</code>","text":"<p>Retrieve the next variation for the experiment based on the wrapper's name.</p> <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The next variation if the experiment is active,</p> <code>Optional[Any]</code> <p>otherwise None.</p> Source code in <code>src/yival/wrappers/base_wrapper.py</code> <pre><code>def get_variation(self) -&gt; Optional[Any]:\n\"\"\"\n    Retrieve the next variation for the experiment based on the wrapper's\n    name.\n\n    Returns:\n        Optional[Any]: The next variation if the experiment is active,\n        otherwise None.\n    \"\"\"\n    if self.experiment_state.active:\n        return self.experiment_state.get_next_variation(self.name)\n    return None\n</code></pre>"},{"location":"custom_classes/data_generators/","title":"Creating a Custom Data Generator with <code>BaseDataGenerator</code>","text":"<p>This guide will walk you through creating a custom data generator using the provided <code>BaseDataGenerator</code>.</p>"},{"location":"custom_classes/data_generators/#introduction","title":"Introduction","text":"<p>The ability to programmatically generate data is crucial in scenarios where synthetic or mock data is required, such as in testing, simulations, and more. The provided foundational architecture for data generators allows for flexibility and extensibility, enabling you to create custom data generators tailored to specific needs.</p> <p>In this guide, we will demonstrate how to create a custom data generator by extending the BaseDataGenerator. Our custom generator will output a list of predefined strings. By following this guide, you'll gain an understanding of the structure and process, enabling you to develop even more complex generators as needed.</p>"},{"location":"custom_classes/data_generators/#step-1-subclassing-the-basedatagenerator","title":"Step 1: Subclassing the <code>BaseDataGenerator</code>","text":"<p>First, create a <code>ListStringDataGenerator</code> that simply outputs a list of strings as specified in its configuration.</p> <pre><code>from typing import Iterator, List\n\nfrom list_string_data_generator_config import ListStringGeneratorConfig\nfrom yival.data_generators.base_data_generator import BaseDataGenerator\nfrom yival.schemas.common_structures import InputData\n\n\n\nclass ListStringDataGenerator(BaseDataGenerator):\n    def __init__(self, config: 'ListStringGeneratorConfig'):\n        super().__init__(config)\n\n    def generate_examples(self) -&gt; Iterator[List[InputData]]:\n        for string_data in self.config.strings_to_generate:\n            yield [InputData(example_id=self.generate_example_id(string_data), content=string_data)]\n</code></pre>"},{"location":"custom_classes/data_generators/#step-2-providing-a-configuration-class","title":"Step 2: Providing a Configuration Class","text":"<p>To specify the list of strings our generator should output, define a custom configuration class:</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import List\n\nfrom yival.schemas.data_generator_configs import BaseDataGeneratorConfig\n\n\n@dataclass\nclass ListStringGeneratorConfig(BaseDataGeneratorConfig):\n\"\"\"\n    Configuration for the ListStringDataGenerator.\n    \"\"\"\n    strings_to_generate: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"custom_classes/data_generators/#config","title":"Config","text":"<p>In your configuration (YAML), you can now specify the use of this data generator:</p> <pre><code>custom_data_generators:\n  list_string_data_generator:\n    class: /path/to/list_string_data_generator.ListStringDataGenerator\n    config_cls: /path/to/list_string_data_generator_config.ListStringGeneratorConfig\n</code></pre> <pre><code>dataset:\ndata_generators:\nlist_string_data_generator:\nstrings_to_generate:\n- abc\n- def\nsource_type: machine_generated\n</code></pre>"},{"location":"custom_classes/evaluators/","title":"Custom Evaluator Creation Guide: SimpleEvaluator","text":""},{"location":"custom_classes/evaluators/#introduction","title":"Introduction","text":"<p>Evaluators are central components in the experimental framework that interpret experiment results and offer either quantitative or qualitative feedback. This guide will walk you through the steps of creating a custom evaluator, named <code>SimpleEvaluator</code>, which returns a value of 1 if the result is 1, and 0 otherwise.</p>"},{"location":"custom_classes/evaluators/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Overview of Base Evaluator</li> <li>Creating the SimpleEvaluator Configuration</li> <li>Implementing the SimpleEvaluator</li> <li>Registering the SimpleEvaluator</li> <li>Conclusion</li> </ol>"},{"location":"custom_classes/evaluators/#overview-of-base-evaluator","title":"Overview of Base Evaluator","text":"<p>The <code>BaseEvaluator</code> class provides the foundational structure for all evaluators. It offers methods to register new evaluators, fetch registered evaluators, and retrieve their configurations. The primary purpose of evaluators is to interpret and analyze the results of experiments based on their unique evaluation logic.</p>"},{"location":"custom_classes/evaluators/#creating-the-simpleevaluator-configuration","title":"Creating the SimpleEvaluator Configuration","text":"<p>Before creating the evaluator, we define the configuration for our <code>SimpleEvaluator</code>. The configuration helps in defining how the evaluator should behave and what parameters it may require.</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import Any, Dict, List\n\nfrom yival.schemas.evaluator_config import (\n    BaseEvaluatorConfig,\n    EvaluatorType,\n    MetricCalculatorConfig,\n)\n\n\n@dataclass\nclass SimpleEvaluatorConfig(BaseEvaluatorConfig):\n\"\"\"\n    Configuration for SimpleEvaluator.\n    \"\"\"\n    metric_calculators: List[MetricCalculatorConfig] = field(\n        default_factory=list\n    )\n    evaluator_type = EvaluatorType.INDIVIDUAL\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        base_dict = super().asdict()\n        base_dict[\"metric_calculators\"] = [\n            mc.asdict() for mc in self.metric_calculators\n        ]\n        return base_dict\n</code></pre>"},{"location":"custom_classes/evaluators/#implementing-the-simpleevaluator","title":"Implementing the SimpleEvaluator","text":"<p>Now, let's create the <code>SimpleEvaluator</code> that utilizes the above configuration:</p> <pre><code>from simple_evaluator import SimpleEvaluatorConfig\nfrom yival.evaluators.base_evaluator import BaseEvaluator\nfrom yival.schemas.evaluator_config import EvaluatorOutput\n\n\n@BaseEvaluator.register(\"simple_evaluator\")\nclass SimpleEvaluator(BaseEvaluator):\n\"\"\"\n    A basic evaluator that returns a value of 1 if the result is 1, and 0\n    otherwise.\n    \"\"\"\n\n    def __init__(self, config: SimpleEvaluatorConfig):\n        super().__init__(config)\n\n    def evaluate(self, experiment_result) -&gt; EvaluatorOutput:\n\"\"\"\n        Evaluate the experiment result and produce an evaluator output.\n\n        Args:\n            experiment_result: The result of an experiment to be evaluated.\n\n        Returns:\n            EvaluatorOutput: The result of the evaluation.\n        \"\"\"\n        result = 1 if experiment_result == 1 else 0\n        return EvaluatorOutput(name=\"Simple Evaluation\", result=result)\n</code></pre>"},{"location":"custom_classes/evaluators/#config","title":"Config","text":"<p>Next you can config the evaluator</p> <pre><code>custom_evaluators:\n  simple_evaluator:\n    class: /path/to/simple_evaluator.SimpleEvaluator\n    config_cls: /path/to/simple_evaluator_config.SimpleEvaluatorConfig\n</code></pre> <p>And use it</p> <pre><code>evaluators:\n  - name: simple_evaluator\n    simple_evaluator:\n      metric_calculators: []\n</code></pre>"},{"location":"custom_classes/evaluators/#conclusion","title":"Conclusion","text":"<p>By following this guide, you've successfully developed, configured, and registered  a custom evaluator named <code>SimpleEvaluator</code> within the experimental framework.  Custom evaluators, like the one you've created, enable a tailored approach to interpreting and analyzing experiment results, ensuring the specific needs of an experiment are met.</p>"},{"location":"custom_classes/improvers/","title":"Custom Combination Improver Creation Guide","text":""},{"location":"custom_classes/improvers/#introduction","title":"Introduction","text":"<p>Combination improvers play a pivotal role in the experimental framework by optimizing the combination of experiments based on their outcomes. By leveraging combination improvers, experiments can be fine-tuned to achieve better results. This guide will outline the process of creating a custom combination improver.</p>"},{"location":"custom_classes/improvers/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Overview of Base Combination Improver</li> <li>Implementing a Custom Combination Improver</li> <li>Registering the Custom Combination Improver</li> <li>Conclusion</li> </ol>"},{"location":"custom_classes/improvers/#overview-of-base-combination-improver","title":"Overview of Base Combination Improver","text":"<p>The <code>BaseCombinationImprover</code> class provides the foundational structure for all combination improvers. It offers methods to:</p> <ul> <li>Register new combination improvers.</li> <li>Fetch registered combination improvers.</li> <li>Retrieve their default configurations.</li> </ul> <p>The main responsibility of a combination improver is to improve the setup of experiments based on their results.</p>"},{"location":"custom_classes/improvers/#implementing-a-custom-combination-improver","title":"Implementing a Custom Combination Improver","text":"<p>To create a custom combination improver, one should inherit from the <code>BaseCombinationImprover</code> class and implement the <code>improve</code> abstract method:</p> <pre><code>class CustomCombinationImprover(BaseCombinationImprover):\n\"\"\"\n    Custom combination improver to optimize the setup of experiments.\n    \"\"\"\n\n    def improve(self, experiment, config, evaluator, token_logger):\n\"\"\"\n        Custom logic to improve the experiment based on its results.\n\n        Args:\n            experiment (Experiment): The experiment with its results.\n            config (ExperimentConfig): The original experiment configuration.\n            evaluator (Evaluator): A utility class to evaluate the\n            ExperimentResult.\n            token_logger (TokenLogger): Logs the token usage.\n\n        Returns:\n            ImproverOutput: The result of the improvement.\n        \"\"\"\n\n        # Custom logic for improvement goes here\n        pass\n</code></pre>"},{"location":"custom_classes/improvers/#config","title":"Config","text":"<pre><code>custom_improvers:\nclass: /path/to/custom_improver.CustomImprover\nconfig_cls: /path/to/custom_improver_config.CustomImproverConfig\n</code></pre> <p>To use it</p> <pre><code>improver:\nname: custom_improver\n</code></pre>"},{"location":"custom_classes/improvers/#conclusion","title":"Conclusion","text":"<p>By following this guide, you have successfully created and registered a custom combination improver named <code>CustomCombinationImprover</code> within the experimental framework. This custom improver will allow you to optimize experiment combinations based on specific logic and criteria you define. As experiments evolve and grow in complexity, custom combination improvers like the one you've developed will become instrumental in achieving more refined and better results.</p>"},{"location":"custom_classes/readers/","title":"Writing a Custom Data Reader in Python with BaseReader","text":"<p>This guide provides steps on how to create custom data readers by subclassing the provided <code>BaseReader</code> class. The example demonstrates how to create a <code>TXTReader</code> to read <code>.txt</code> files.</p>"},{"location":"custom_classes/readers/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>BaseReader Overview</li> <li>Creating a Custom Reader (TXTReader)</li> <li>Conclusion</li> </ol>"},{"location":"custom_classes/readers/#1-introduction","title":"1. Introduction","text":"<p>Data readers are responsible for reading data from various sources. By subclassing the <code>BaseReader</code>, you can create custom readers tailored to your specific data format needs.</p>"},{"location":"custom_classes/readers/#2-basereader-overview","title":"2. BaseReader Overview","text":"<p>The <code>BaseReader</code> class offers a blueprint for designing data readers. It has methods to:</p> <ul> <li>Register new readers.</li> <li>Retrieve registered readers and their configurations.</li> <li>Read data in chunks.</li> </ul> <p>The class provides an abstract method <code>read</code> that you must override in your custom reader. The method is designed to read data in chunks for efficient parallel processing.</p>"},{"location":"custom_classes/readers/#3-creating-a-custom-reader-txtreader","title":"3. Creating a Custom Reader (TXTReader)","text":""},{"location":"custom_classes/readers/#31-design-the-txtreaderconfig-class","title":"3.1. Design the TXTReaderConfig Class","text":"<p>Before creating the reader, design a configuration class specific to the <code>TXTReader</code>. This class will inherit from the base <code>BaseReaderConfig</code>:</p> <pre><code>from dataclasses import asdict, dataclass\nfrom yival.data.base_reader import BaseReaderConfig\n\n@dataclass\nclass TXTReaderConfig(BaseReaderConfig):\n\"\"\"\n    Configuration specific to the TXT reader.\n    \"\"\"\n\n    delimiter: str = \"\\n\"  # Default delimiter for txt files.\n\n    def asdict(self):\n        return asdict(self)\n</code></pre>"},{"location":"custom_classes/readers/#32-implement-the-txtreader-class","title":"3.2. Implement the TXTReader Class","text":"<p>Now, create the <code>TXTReader</code> class, subclassing the <code>BaseReader</code>:</p> <pre><code>from typing import Iterator, List\n\nfrom txt_reader_config import TXTReaderConfig\nfrom yival.data.base_reader import BaseReader\nfrom yival.schemas.common_structures import InputData\n\nclass TXTReader(BaseReader):\n\"\"\"\n    TXTReader is a class derived from BaseReader to read datasets from TXT\n    files.\n\n    Attributes:\n        config (TXTReaderConfig): Configuration object specifying reader parameters.\n\n    Methods:\n        __init__(self, config: TXTReaderConfig): Initializes the TXTReader with\n        a given configuration.\n        read(self, path: str) -&gt; Iterator[List[InputData]]: Reads the TXT file\n        and yields chunks of InputData.\n    \"\"\"\n\n    config: TXTReaderConfig\n    default_config = TXTReaderConfig()\n\n    def __init__(self, config: TXTReaderConfig):\n        super().__init__(config)\n        self.config = config\n\n    def read(self, path: str) -&gt; Iterator[List[InputData]]:\n        chunk = []\n        chunk_size = self.config.chunk_size\n\n        with open(path, mode=\"r\", encoding=\"utf-8\") as file:\n            for line in file:\n                line_content = line.strip().split(self.config.delimiter)\n\n                # Each line in the TXT file is treated as a separate data point.\n                example_id = self.generate_example_id({\"content\": line_content}, path)\n                input_data_instance = InputData(\n                    example_id=example_id,\n                    content=line_content\n                )\n                chunk.append(input_data_instance)\n\n                if len(chunk) &gt;= chunk_size:\n                    yield chunk\n                    chunk = []\n\n            if chunk:\n                yield chunk\n</code></pre>"},{"location":"custom_classes/readers/#33-config","title":"3.3. Config","text":"<p>After defining the config and reader sublass, we can define the yml config:</p> <pre><code>custom_reader:\ntxt_reader:\nclass: /path/to/text_reader.TXTReader\nconfig_cls: /path/to/txt_reader_config.TXTReaderConfig\n</code></pre> <pre><code>dataset:\nsource_type: dataset\nreader: txt_reader\nfile_path: \"/Users/taofeng/YiVal/data/headline_generation.txt\"\nreader_config:\ndelimiter: \"\\n\"\n</code></pre>"},{"location":"custom_classes/readers/#4-conclusion","title":"4. Conclusion","text":"<p>Creating custom data readers with the provided framework is straightforward. You can design readers tailored to various data formats by simply subclassing the <code>BaseReader</code> and overriding its <code>read</code> method. With this capability, you can efficiently read data in chunks, making it suitable for parallel processing and large datasets.</p>"},{"location":"custom_classes/selection_strategy/","title":"Custom Selection Strategy Creation Guide","text":""},{"location":"custom_classes/selection_strategy/#introduction","title":"Introduction","text":"<p>Selection strategies are paramount in the experimental framework, guiding the selection or prioritization of experiments, scenarios, or configurations. These strategies can be based on a variety of criteria, ranging from past performance to specific business rules. In this guide, we'll outline the process for creating your own custom selection strategy.</p>"},{"location":"custom_classes/selection_strategy/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>The Essence of Selection Strategy</li> <li>Crafting a Custom Selection Strategy</li> <li>Registering Your Custom Strategy</li> <li>Conclusion</li> </ol>"},{"location":"custom_classes/selection_strategy/#the-essence-of-selection-strategy","title":"The Essence of Selection Strategy","text":"<p>The <code>SelectionStrategy</code> class is the backbone of all selection strategies. It encapsulates core methods to:</p> <ul> <li>Register new selection strategies.</li> <li>Retrieve registered strategies.</li> <li>Access their default configurations.</li> </ul> <p>At its core, a selection strategy's primary task is to decide how to select or prioritize specific experiments or configurations.</p>"},{"location":"custom_classes/selection_strategy/#crafting-a-custom-selection-strategy","title":"Crafting a Custom Selection Strategy","text":"<p>To devise a custom selection strategy, you should inherit from the <code>SelectionStrategy</code> class and implement the <code>select</code> abstract method:</p> <pre><code>class CustomSelectionStrategy(SelectionStrategy):\n\"\"\"\n    Custom strategy for selecting experiments.\n    \"\"\"\n\n    def select(self, experiment):\n\"\"\"\n        Custom logic for selecting or prioritizing experiments.\n\n        Args:\n            experiment (Experiment): The experiment under consideration.\n\n        Returns:\n            SelectionOutput: The result of the selection process.\n        \"\"\"\n\n        # Your selection logic goes here\n        pass\n</code></pre>"},{"location":"custom_classes/selection_strategy/#config","title":"Config","text":"<pre><code>custom_selection_strategies:\n  custom_selection_strategy:\n    class: /path/to/custom_selection_strategy.CustomSelectionStrategy\n    config_cls: /path/to/custom_selection_strategy.CustomSelectionStrategyConfig\n</code></pre> <p>To use it</p> <pre><code>selection_strategy:\n  custom_selection_strategies:\n</code></pre>"},{"location":"custom_classes/variation_generators/","title":"Writing a Custom Variation Generator Subclass","text":"<p>This guide explains how to create a custom variation generator subclass based on the <code>BaseVariationGenerator</code> for experimental variations.</p>"},{"location":"custom_classes/variation_generators/#1-understand-the-base","title":"1. Understand the Base","text":"<p>The <code>BaseVariationGenerator</code> provides foundational methods and attributes for all variation generators. Subclasses should implement the <code>generate_variations</code> method to define the logic for producing variations.</p>"},{"location":"custom_classes/variation_generators/#2-example-simplevariationgenerator","title":"2. Example: SimpleVariationGenerator","text":"<p>Let's design a generator that simply returns variations based on the configurations provided.</p>"},{"location":"custom_classes/variation_generators/#21-define-the-configuration-class","title":"2.1 Define the Configuration Class","text":"<p>Firstly, you'll need a configuration class specific to your generator:</p> <pre><code>from dataclasses import dataclass\nfrom yival.schemas.varation_generator_configs import BaseVariationGeneratorConfig\n\n@dataclass\nclass SimpleVariationGeneratorConfig(BaseVariationGeneratorConfig):\n    variations: Optional[List[str]] = None  # List of variations to generate\n</code></pre> <p>This configuration class inherits from <code>BaseVariationGeneratorConfig</code> and has an additional attribute, <code>variations</code>, which is a list of variation strings.</p>"},{"location":"custom_classes/variation_generators/#22-implement-the-variation-generator","title":"2.2 Implement the Variation Generator","text":"<p>Now, let's create the custom variation generator:</p> <pre><code>from typing import Iterator, List\n\nfrom yival.schemas.experiment_config import WrapperVariation\nfrom yival.variation_generators.base_variation_generator import BaseVariationGenerator\n\nclass SimpleVariationGenerator(BaseVariationGenerator):\n\n    def __init__(self, config: SimpleVariationGeneratorConfig):\n        super().__init__(config)\n        self.config = config\n\n    def generate_variations(self) -&gt; Iterator[List[WrapperVariation]]:\n        variations = [WrapperVariation(value_type=\"str\", value=var) for var in self.config.variations]\n        yield variations\n</code></pre> <p>Here, the <code>generate_variations</code> method simply converts the list of variation strings from the configuration into a list of <code>WrapperVariation</code> objects and yields it.</p>"},{"location":"custom_classes/variation_generators/#3-using-the-custom-variation-generator-in-configuration","title":"3. Using the Custom Variation Generator in Configuration","text":"<p>In your configuration (YAML), you can now specify the use of this variation generator:</p> <pre><code>custom_variation_generators:\nsimple_variation_generator:\nclass: /path/to/simple_variation_generator.SimpleVariationGenerator\nconfig_cls: /path/to/simple_variation_generator_config.SimpleVariationGeneratorConfig\n</code></pre> <pre><code>variations:\n- name: task\ngenerator_name: simple_variation_generator\ngenerator_config:\nvariations:\n- abc\n- def\n</code></pre> <p>This configuration will use the <code>SimpleVariationGenerator</code> and produce the variations \"variation1\" and \"variation2\".</p>"},{"location":"custom_classes/wrappers/","title":"Custom Wrapper Creation Guide: NumberWrapper","text":""},{"location":"custom_classes/wrappers/#introduction","title":"Introduction","text":"<p>In the experimental framework, wrappers play a vital role in managing variations throughout an experiment's lifecycle. By creating custom wrappers, one can control and monitor variations tailored to specific needs, ensuring that the experiment operates smoothly and efficiently.</p> <p>In this guide, we will walk you through the process of creating a custom wrapper named <code>NumberWrapper</code>. This wrapper will handle variations specifically for numbers. By the end of this guide, you will have a clear understanding of creating and registering a custom wrapper within the experimental framework.</p>"},{"location":"custom_classes/wrappers/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Base Wrapper Overview</li> <li>Creating a NumberWrapper</li> <li>Registering the NumberWrapper</li> <li>Conclusion</li> </ol>"},{"location":"custom_classes/wrappers/#base-wrapper-overview","title":"Base Wrapper Overview","text":"<p>The <code>BaseWrapper</code> class provides the fundamental structure for wrappers. It comes equipped with methods to register new wrappers, retrieve registered ones, and fetch their configurations. The primary purpose of a wrapper is to manage experiment variations based on the global experiment state.</p>"},{"location":"custom_classes/wrappers/#creating-a-numberwrapper","title":"Creating a NumberWrapper","text":"<p>The <code>NumberWrapper</code> will be a custom wrapper designed to handle variations specifically for numbers.</p> <pre><code>from typing import Optional\n\nfrom number_wrapper_config import NumberWrapperConfig\nfrom yival.wrappers.base_wrapper import BaseWrapper\n\n\nclass NumberWrapper(BaseWrapper):\n\"\"\"\n    A wrapper for numbers to manage experiment variations based on the global\n    experiment state. If a variation for the given experiment name exists and\n    the global ExperimentState is active, the variation is used. Otherwise,\n    the original number is returned.\n    \"\"\"\n    default_config = NumberWrapperConfig()\n\n    def __init__(\n        self,\n        value: float,\n        name: str,\n        config: Optional[NumberWrapperConfig] = None\n    ) -&gt; None:\n        super().__init__(name, config)\n        self._value = value\n\n    def get_value(self) -&gt; float:\n        variation = self.get_variation()\n        if variation is not None:\n            return variation\n        return self._value\n</code></pre> <p>Here, the <code>NumberWrapper</code> class is responsible for retrieving a variation if one exists, otherwise returning the original number. The <code>get_value</code> method is used to fetch the number, considering any variations.</p>"},{"location":"custom_classes/wrappers/#registering-the-numberwrapper","title":"Registering the NumberWrapper","text":"<p>To make the <code>NumberWrapper</code> usable within the experimental framework, it needs to be registered. The registration process involves mapping the wrapper's name to its class and configuration.</p> <pre><code>from dataclasses import dataclass\n\nfrom yival.schemas.wrapper_configs import BaseWrapperConfig\n\n\n@dataclass\nclass NumberWrapperConfig(BaseWrapperConfig):\n\"\"\"\n    Configuration specific to the NumberWrapper.\n    \"\"\"\n    pass\n</code></pre> <p>By calling the <code>register_wrapper</code> method, the <code>NumberWrapper</code> becomes available for use in the experimental framework.</p>"},{"location":"custom_classes/wrappers/#config","title":"Config","text":"<p>Now you can cofig the wrapper in yml</p> <pre><code>custom_wrappers:\n  number_wrapper:\n    class: /path/to/number_wrapper.NumberWrapper\n    config_cls: /path/to/number_wrapper_config.NumberWrapperConfig\n</code></pre> <p>And you should be able to use the wrapper in your code like string wrapper.</p>"},{"location":"custom_classes/wrappers/#conclusion","title":"Conclusion","text":"<p>By following this guide, you've successfully created and registered a custom wrapper named <code>NumberWrapper</code> in the experimental framework. This flexibility allows you to tailor experiments to specific needs, ensuring accurate and efficient results.</p>"}]}